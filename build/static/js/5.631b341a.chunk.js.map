{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../src/context/ApolloContext.ts","../../src/parser/parser.ts","../../src/context/ApolloProvider.tsx","../node_modules/tslib/tslib.es6.js","../../src/invariant.ts","../../src/storeUtils.ts","../../src/directives.ts","../../src/fragments.ts","../../src/util/assign.ts","../../src/getFromAST.ts","../../src/util/filterInPlace.ts","../../src/transform.ts","../../src/util/canUse.ts","../../src/util/cloneDeep.ts","../../src/util/environment.ts","../../src/util/errorHandling.ts","../../src/util/maybeDeepFreeze.ts","../../src/util/mergeDeep.ts","../../src/util/warnOnce.ts","../../src/core/networkStatus.ts","../../src/util/Observable.ts","../../src/util/arrays.ts","../../src/errors/ApolloError.ts","../../src/core/types.ts","../../src/core/ObservableQuery.ts","../../src/data/mutations.ts","../../src/data/queries.ts","../../src/core/LocalState.ts","../../src/util/capitalizeFirstLetter.ts","../../src/util/observables.ts","../../src/core/QueryManager.ts","../../src/data/store.ts","../../src/version.ts","../../src/ApolloClient.ts","../../src/zenObservable.ts","../../src/equality.ts","../node_modules/graphql/language/visitor.mjs","../node_modules/react-apollo-hooks/es/utils.js","../node_modules/graphql/jsutils/inspect.mjs","../node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs","../node_modules/graphql/language/blockString.mjs","../../src/linkUtils.ts","../../src/link.ts","../node_modules/graphql/language/printer.mjs","../node_modules/react-apollo-hooks/es/ApolloContext.js","../node_modules/react-apollo-hooks/es/internal/actHack.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js","../node_modules/graphql-tag/src/index.js","../node_modules/symbol-observable/es/index.js","../node_modules/webpack/buildin/harmony-module.js","../node_modules/symbol-observable/es/ponyfill.js","../node_modules/zen-observable/index.js","../node_modules/zen-observable/lib/Observable.js","../node_modules/fast-json-stable-stringify/index.js","../node_modules/lodash/isPlainObject.js","../node_modules/lodash/_getPrototype.js","../node_modules/lodash/_overArg.js","../node_modules/graphql/jsutils/devAssert.mjs","../node_modules/graphql/jsutils/defineToJSON.mjs","../node_modules/graphql/jsutils/isObjectLike.mjs","../node_modules/graphql/language/location.mjs","../node_modules/graphql/language/printLocation.mjs","../node_modules/graphql/error/GraphQLError.mjs","../node_modules/graphql/error/syntaxError.mjs","../node_modules/graphql/language/kinds.mjs","../node_modules/graphql/language/source.mjs","../node_modules/graphql/jsutils/defineToStringTag.mjs","../node_modules/graphql/language/tokenKind.mjs","../node_modules/graphql/language/lexer.mjs","../node_modules/graphql/language/directiveLocation.mjs","../node_modules/graphql/language/parser.mjs","../../src/utils.ts","../../src/types/Cache.ts","../../src/cache.ts","../../src/slot.ts","../../src/context.ts","../../src/entry.ts","../../src/key-trie.ts","../../src/index.ts","../../src/fragmentMatcher.ts","../../src/depTrackingCache.ts","../../src/readFromStore.ts","../../src/objectCache.ts","../../src/writeToStore.ts","../../src/inMemoryCache.ts","../../src/httpLink.ts","../node_modules/react-apollo-hooks/es/useMutation.js","../node_modules/react-apollo-hooks/es/internal/SSRContext.js","../node_modules/react-apollo-hooks/es/queryCache.js","../node_modules/react-apollo-hooks/es/useQuery.js","../../src/data/OperationData.ts","../../src/data/QueryData.ts","../../src/utils/useBaseQuery.ts","../../src/utils/useDeepMemo.ts","../../src/data/MutationData.ts","../../src/data/SubscriptionData.ts","../../src/ssr/RenderPromises.ts","../../src/Query.tsx","../../src/useQuery.ts","../../src/Mutation.tsx","../../src/useMutation.ts","../../src/Subscription.tsx","../../src/useSubscription.ts"],"names":["_slicedToArray","arr","i","Array","isArray","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","value","length","err","TypeError","apolloContext","getApolloContext","createContext","DocumentType","ApolloProvider","client","children","ApolloContext","context","assign","Provider","cache","Map","operationName","type","name","Query","Mutation","Subscription","parser","document","variables","cached","get","fragments","definitions","filter","x","kind","queries","operation","mutations","subscriptions","extendStatics","d","b","setPrototypeOf","__proto__","p","hasOwnProperty","__extends","__","this","constructor","create","__assign","t","s","n","arguments","apply","__rest","e","indexOf","getOwnPropertySymbols","propertyIsEnumerable","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","rejected","result","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","v","op","pop","__spreadArrays","il","r","k","a","j","jl","genericMessage","message","framesToPop","InvariantError","Error","invariant","condition","wrapConsoleMethod","method","console","warn","error","processStub","env","process","Function","atLeastWeTried","valueToObjectRepresentation","argObj","isIntValue","isFloatValue","Number","isBooleanValue","isStringValue","isObjectValue","fields","map","obj","isVariable","variableValue","isListValue","values","listValue","nestedArgArrayObj","isEnumValue","isNullValue","storeKeyNameFromField","field","directivesObj","directives","forEach","directive","getStoreKeyName","KNOWN_DIRECTIVES","fieldName","args","filterKeys","sort","key","JSON","stringify","completeFieldName","stringifiedArgs","keys","argumentsObjectFromField","resultKeyNameFromField","alias","isField","selection","isInlineFragment","isIdValue","idObject","generated","toIdValue","idConfig","id","typename","isJsonValue","jsonObject","getDirectiveInfoFromField","shouldInclude","isInclusionDirective","directiveArguments","ifArgument","ifValue","every","evaledValue","hasDirectives","names","doc","Directive","node","getDirectiveNames","some","hasClientExports","getFragmentQueryDocument","fragmentName","actualFragmentName","definition","selectionSet","selections","target","sources","source","checkDocument","operations","getOperationDefinition","getOperationName","getFragmentDefinitions","getQueryDefinition","queryDef","getMainDefinition","queryDoc","fragmentDefinition","createFragmentMap","symTable","fragment","getDefaultValues","variableDefinitions","defaultValues","defaultValue","variable","defaultValueObj","filterInPlace","array","test","elem","TYPENAME_FIELD","nullIfDocIsEmpty","isEmpty","fragmentDef","getFragmentDefinition","getDirectiveMatcher","dir","removeDirectivesFromDocument","variablesInUse","variablesToRemove","fragmentSpreadsInUse","fragmentSpreadsToRemove","modifiedDoc","Variable","enter","_key","parent","Field","remove","arg","getAllFragmentSpreadsFromSelectionSet","allFragments","frag","FragmentSpread","config","argMatcher","argument","aConfig","getArgumentMatcher","OperationDefinition","varDef","argConfig","Argument","removeArgumentsFromDocument","fs","def","FragmentDefinition","removeFragmentSpreadFromDocument","addTypenameToDocument","SelectionSet","lastIndexOf","connectionRemoveConfig","willRemove","removeConnectionDirectiveFromDocument","buildQueryFromSelectionSet","removeClientSetsFromDocument","canUseWeakMap","WeakMap","navigator","product","cloneDeep","cloneDeepHelper","val","seen","has","slice","set","child","getPrototypeOf","isEnv","isProduction","isTest","tryFunctionOrLogError","graphQLResultHasError","errors","maybeDeepFreeze","deepFreeze","o","freeze","getOwnPropertyNames","prop","isFrozen","mergeDeep","mergeDeepArray","count","pastCopies","shallowCopyForMerge","mergeHelper","isObject","isExtensible","sourceKey","sourceValue","targetValue","NetworkStatus","isNetworkRequestInFlight","networkStatus","LinkObservable","isNonEmptyArray","FetchType","generateErrorMessage","graphQLErrors","graphQLError","errorMessage","networkError","replace","extraInfo","ApolloError","queryManager","options","shouldSubscribe","observer","onSubscribe","observers","Set","isTornDown","queryId","generateQueryId","opDef","query","queryName","delete","size","removeQuery","setTimeout","subscription","unsubscribe","subscribe","currentResult","getCurrentResult","data","lastResult","lastError","loading","storeValue","policy","partial","queryStoreValue","queryStore","fetchPolicy","isNetworkFetchPolicy","errorPolicy","ready","updateLastResult","stale","isDifferentFromLastResult","newResult","lastResultSnapshot","snapshot","getLastResult","getLastError","resetLastResults","resetQueryStoreErrors","refetch","fetchQuery","fetchMore","fetchMoreOptions","combinedOptions","qid","normal","fetchMoreResult","updateQuery","previousResult","stopQuery","subscribeToMore","startGraphQLSubscription","subscriptionData","previous","onError","add","setOptions","opts","pollInterval","startPolling","stopPolling","setVariables","oldFetchPolicy","fetchResults","tryFetch","mapFn","dataStore","markUpdateQueryResult","broadcastQueries","stopPollingQuery","assertNotCacheFirstOrOnly","startPollingQuery","assumeImmutableResults","subObserver","_subscription","_observer","defaultSubscriptionObserverErrorCallback","first","setUpQuery","tearDownQuery","addObservableQuery","iterateObserversSafely","observeQuery","transform","getLocalState","addExportedVariables","previousVariables","serverQuery","catch","sub","clear","removeObservableQuery","Observable","observersWithMethod","obs","obsQuery","store","getStore","mutationId","initMutation","mutation","markMutationError","markMutationResult","reset","initQuery","previousQuery","resolvers","fragmentMatcher","addResolvers","setFragmentMatcher","resolverGroup","setResolvers","getResolvers","runResolvers","remoteResult","onlyRunForcedResolvers","resolveDocument","localResult","getFragmentMatcher","clientQuery","prepareContext","getCacheKey","dataIdFromObject","buildRootValueFromCache","exportedVariables","shouldForceResolvers","forceResolvers","diff","returnPartialData","optimistic","rootValue","str","mainDefinition","fragmentMap","definitionOperation","defaultOperationType","charAt","toUpperCase","execContext","resolveSelectionSet","resultsToMerge","execute","resolveField","fieldResult","typeCondition","fragmentResult","all","aliasedFieldName","aliasUsed","defaultResult","resultPromise","resolverType","__typename","resolverMap","resolveSubSelectedArray","item","multiplex","inner","complete","link","queryDeduplication","onBroadcast","ssrMode","clientAwareness","localState","mutationStore","MutationStore","QueryStore","idCounter","fetchQueryRejectFns","transformCache","inFlightLinkObservables","pollingInfoByQueryId","LocalState","getCache","stop","_info","stopQueryNoBroadcast","mutate","optimisticResponse","updateQueries","refetchQueries","awaitRefetchQueries","update","setQuery","getVariables","generateUpdateQueriesInfo","ret","updateQueriesByName","observableQuery","updater","markMutationInit","updateWithProxyFn","self","storeResult","getObservableFromLink","markMutationComplete","refetchQueryPromises","refetchQuery","queryOptions","fetchType","fetchMoreForQueryId","metadata","needToFetch","isNetworkOnly","shouldFetch","requestId","cancel","updateQueryWatch","lastRequestId","invalidated","invalidate","storePreviousVariables","isPoll","poll","isRefetch","networkResult","fetchRequest","getQuery","markQueryError","markQueryResultClient","hasForcedResolvers","markQueryResult","newData","queryListenerForObserver","invoke","networkStatusChanged","shouldNotifyIfLoading","notifyOnNetworkStatusChange","hasGraphQLErrors","isMissing","errorStatusChanged","diffResult","resultFromStore","transformed","transformDocument","forLink","transformForLink","defaultVars","watchQuery","transformedOptions","ObservableQuery","watchedQuery","String","stopQueryInStore","stopQueryInStoreNoBroadcast","addQueryListener","listener","listeners","watch","callback","clearStore","resetIds","resetStore","reFetchObservableQueries","includeStandby","observableQueryPromises","startQuery","makeObservable","markSubscriptionResult","observable","getCurrentQueryResult","getQueryWithPreviousResult","queryIdOrObservable","foundObserveableQuery","info","deduplication","forceFetch","cleanup","of","activeNextCount","completed","handler","asyncMap","errorsFromStore","fqrfId","prev","newInfo","newContext","checkInFlight","interval","clearTimeout","timeout","initialCache","ignoreErrors","writeWithErrors","write","dataId","recordOptimisticTransaction","c","orig","nextQueryResult","currentQueryResult","mutationResult","queryVariables","performTransaction","removeOptimistic","version","defaultOptions","resetStoreCallbacks","clearStoreCallbacks","ssrForceFetchDelay","connectToDevTools","typeDefs","empty","DataStore","disableNetworkFetches","bind","window","__APOLLO_CLIENT__","QueryManager","clientAwarenessName","clientAwarenessVersion","devToolsHookCb","action","state","dataWithOptimisticResults","extract","readQuery","readFragment","writeQuery","writeFragment","writeData","__actionHookForDevTools","cb","__requestRaw","payload","initQueryManager","fn","onResetStore","onClearStore","restore","serializedState","setLocalStateFragmentMatcher","previousComparisons","equal","check","aTag","bTag","previouslyCompared","aKeys","bKeys","keyCount","aIterator","entries","isMap","aKey","aValue","bSet","QueryDocumentKeys","Name","Document","VariableDefinition","InlineFragment","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","BREAK","visit","root","visitor","visitorKeys","stack","inArray","index","edits","path","ancestors","newRoot","isLeaving","isEdited","clone","_i2","_Object$keys2","editOffset","ii","editKey","editValue","splice","isNode","inspect","visitFn","getVisitFn","maybeNode","Boolean","kindVisitor","kindSpecificVisitor","leave","specificVisitor","specificKindVisitor","objToKey","isPlainObject","sortedObj","reduce","compact","acc","_typeof","MAX_ARRAY_LENGTH","MAX_RECURSIVE_DEPTH","formatValue","seenValues","concat","previouslySeenValues","customInspectFn","object","nodejsCustomInspectSymbol","getCustomFn","customValue","len","Math","min","remaining","items","join","formatArray","tag","getObjectTag","formatObject","formatObjectValue","for","dedentBlockStringValue","rawString","lines","split","commonIndent","line","indent","leadingWhitespace","getBlockStringIndentation","isBlank","shift","printBlockString","indentation","preferMultipleLines","isSingleLine","hasLeadingSpace","hasTrailingQuote","printAsMultipleLines","isTerminating","request","fromError","errorValue","createOperation","starting","defineProperty","enumerable","getKey","passthrough","forward","toLink","ApolloLink","from","links","left","right","leftLink","rightLink","second","firstLink","nextLink","transformedOperation","extensions","transformOperation","OPERATION_FIELDS","validateOperation","print","ast","printDocASTReducer","varDefs","wrap","_ref","_ref2","block","_ref3","_ref4","_ref5","_ref6","_ref7","_ref8","_ref9","_ref10","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","operationTypes","_ref21","addDescription","_ref22","_ref23","interfaces","_ref24","hasMultilineItems","_ref25","_ref26","_ref27","types","_ref28","_ref29","_ref30","_ref31","repeatable","locations","_ref32","_ref33","_ref34","_ref35","_ref36","_ref37","_ref38","description","maybeArray","separator","start","maybeString","end","isMultiline","string","React","createElement","useApolloClient","overrideClient","useContext","actHack","_taggedTemplateLiteral","strings","raw","defineProperties","parse","require","normalize","trim","docCache","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","parseDocument","cacheKey","parsed","stripLoc","removeLocAtThisLevel","docType","loc","startToken","endToken","valueType","astFragmentMap","substring","processFragments","gql","literals","default","resetCaches","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","module","exports","global","ponyfill","originalModule","webpackPolyfill","l","symbolObservablePonyfill","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","configurable","writable","_createClass","protoProps","staticProps","hasSymbols","hasSymbol","getSymbol","SymbolIterator","SymbolObservable","SymbolSpecies","getMethod","getSpecies","ctor","isObservable","hostReportError","log","enqueue","cleanupSubscription","_cleanup","closeSubscription","_queue","_state","notifySubscription","m","onNotify","queue","flushSubscription","subscriber","subscriptionObserver","SubscriptionObserver","_subscriber","_this","_this2","_this3","_this4","C","hasSeed","hasValue","seed","_this5","_len","startNext","_this6","outer","completeIfDone","closed","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_item","return","_len2","_key2","symbol","cmp","cycles","aobj","bobj","toJSON","isFinite","out","seenIndex","baseGetTag","getPrototype","isObjectLike","objectTag","funcProto","objectProto","funcToString","objectCtorString","proto","Ctor","overArg","func","devAssert","defineToJSON","classObject","getLocation","position","match","lineRegexp","column","exec","printLocation","location","printSourceLocation","sourceLocation","firstLineColumnOffset","locationOffset","whitespace","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","locationLine","sublineIndex","floor","sublineColumnNum","sublines","printPrefixedLines","subline","existingLines","padLen","max","prefix","GraphQLError","nodes","positions","originalError","_nodes","_source","_locations","_positions","list","pos","_extensions","originalExtensions","captureStackTrace","syntaxError","output","_error$nodes2","_i4","_error$locations2","printError","Kind","NAME","DOCUMENT","OPERATION_DEFINITION","VARIABLE_DEFINITION","SELECTION_SET","FIELD","ARGUMENT","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","LIST","OBJECT","OBJECT_FIELD","DIRECTIVE","NAMED_TYPE","LIST_TYPE","NON_NULL_TYPE","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","FIELD_DEFINITION","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","ENUM_VALUE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","DIRECTIVE_DEFINITION","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","Source","toStringTag","TokenKind","SOF","EOF","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","BLOCK_STRING","COMMENT","advanceLexer","lastToken","token","lookahead","readToken","Tok","printCharCode","code","isNaN","fromCharCode","lexer","bodyLength","startPosition","charCodeAt","lineStart","positionAfterWhitespace","col","readComment","readName","firstCode","isFloat","readDigits","readNumber","chunkStart","rawValue","readBlockString","charCode","char2hex","invalidSequence","readString","unexpectedCharacterMessage","DirectiveLocation","QUERY","MUTATION","SUBSCRIPTION","SCHEMA","SCALAR","ARGUMENT_DEFINITION","INTERFACE","UNION","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","Parser","parseValue","expectToken","parseValueLiteral","parseType","parseTypeReference","sourceObj","_lexer","startOfFileToken","advance","createLexer","_options","_proto","parseName","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","peekDescription","unexpected","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","parseVariable","expectOptionalToken","parseSelection","parseFragment","parseField","nameOrAlias","parseArguments","isConst","parseConstArgument","parseArgument","hasTypeCondition","expectOptionalKeyword","parseFragmentName","parseNamedType","expectKeyword","parseList","parseObject","parseStringLiteral","any","parseObjectField","parseDirective","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","parseOperationTypeDefinition","parseImplementsInterfaces","parseFieldsDefinition","allowLegacySDLImplementsInterfaces","allowLegacySDLEmptyFields","parseFieldDefinition","parseArgumentDefs","parseInputValueDef","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","parseDirectiveLocations","parseDirectiveLocation","noLocation","Loc","getTokenDesc","atToken","openKind","parseFn","closeKind","queryFromPojo","selectionSetFromObj","Cache","justTypenameQuery","currentContext","MISSING_VALUE","host","Slot","Date","now","random","slots","getValue","withValue","saved","noContext","defaultDispose","dispose","newest","oldest","entry","getEntry","older","newer","clean","parentEntrySlot","reusableEmptyArray","emptySetPool","POOL_TARGET_SIZE","assert","optionalMessage","valueGet","parents","childValues","dirtyChildren","dirty","recomputing","Entry","recompute","mightBeDirty","reportDirtyChild","reportCleanChild","rememberParent","maybeReportOrphan","originalChildren","forgetChildren","recomputeNewValue","maybeUnsubscribe","setDirty","maybeSubscribe","reportClean","setClean","reallyRecompute","reportDirty","forgetChild","childValue","valueIs","removeDirtyChild","dc","reportOrphan","_value","weakness","lookup","lookupArray","getChildTrie","isObjRef","weak","strong","KeyTrie","haveWarned","shouldWarn","answer","ensureReady","canBypassInit","idValue","isRootQuery","hasOwn","introspectionQueryResultData","possibleTypesMap","parseIntrospectionResult","isReady","implementingTypes","introspectionResultData","typeMap","__schema","possibleTypes","implementingType","depend","disposable","makeCacheKey","toObject","defaultNormalizedCacheFactory","cacheKeyRoot","freezeResults","executeStoreQuery","executeSelectionSet","executeSubSelectedArray","contextValue","variableValues","readQueryFromStore","diffQueryAgainstStore","rootId","fragmentMatcherFunction","queryDefinition","cacheRedirects","execResult","hasMissingFields","missing","tolerable","finalResult","objectsToMerge","handleMissing","executeField","fragmentExecResult","readStoreResult","resultKey","storeKeyName","fieldValue","resolver","storeObj","json","readStoreResolver","combineExecResults","assertSelectionSetForIdValue","execResults","childResult","defaultFragmentMatcher","writeQueryToStore","writeResultToStore","operationDefinition","writeSelectionSetToStore","processedData","enhancedError","enhanceErrorWithDocument","resultFieldKey","writeFieldToStore","isDefered","isClient","matches","fakeContext","ObjectCache","storeObject","storeFieldName","generatedId","processArrayValue","valueDataId","isGeneratedId","semanticId","isDataProcessed","escapedId","hadTypename","hasTypename","typenameChanged","mergeWithGenerated","generatedKey","realKey","real","madeChanges","realValue","newRealValue","itemDataId","defaultConfig","HeuristicFragmentMatcher","_id","addTypename","resultCaching","optimisticId","transaction","watches","typenameDocumentCache","silenceBroadcast","customResolvers","cacheResolvers","optimisticData","storeWriter","storeReader","maybeBroadcastWatch","read","broadcastWatches","evict","idToRemove","toReapply","removedCount","layer","fallbackHttpConfig","http","includeQuery","includeExtensions","headers","accept","throwServerError","response","statusCode","status","serialized","parseError","linkOptions","uri","fetch","useGETForQueries","fetcher","linkConfig","requestOptions","fetchOptions","credentials","chosenURI","fallbackURI","contextURI","getContext","selectURI","clientAwarenessHeaders","controller","contextHeaders","contextConfig","fallbackConfig","configs","signal","AbortController","_controller","queryParams","addQueryParam","encodeURIComponent","serializedVariables","serializedExtensions","preFragment","fragmentStart","substr","queryParamsPrefix","newURI","setContext","text","bodyText","abort","_extends","getInitialState","called","hasError","useMutation","baseOptions","_React$useState","useState","setResult","_baseOptions","_baseOptions$rethrow","rethrow","excluded","sourceKeys","_objectWithoutPropertiesLoose","mergeResult","partialResult","useEffect","_useMutationTracking","mostRecentMutationId","useRef","generateNewMutationId","current","isMostRecentMutation","useMutationTracking","onMutationError","useCallback","mutateOptions","mutateVariables","onMutationCompleted","SSRContext","cachedQueriesByClient","getCachedQueriesForClient","queriesForClient","useQuery","_temp","_ref$ssr","ssr","_ref$skip","skip","_ref$suspend","suspend","_ref$notifyOnNetworkS","actualCachePolicy","ssrManager","ssrInUse","shouldSkip","watchQueryOptions","useMemo","getCachedObservableQuery","_useState","responseId","setResponseId","helpers","invalidateCurrentResult","invalidateCachedObservableQuery","ensureSupportedFetchPolicy","register","isMounted","previousOptions","getOptions","newOptions","storePrevious","isEqual","unmount","refreshClient","isNew","verifyDocumentType","forceUpdate","previousData","currentObservable","runLazy","runLazyQuery","lazyOptions","getExecuteResult","getQueryResult","startQuerySubscription","obsRefetch","obsFetchMore","obsUpdateQuery","obsStartPolling","obsStopPolling","obsSubscribeToMore","removeQuerySubscription","updateObservableQuery","getExecuteSsrResult","executeLazy","fetchData","afterExecute","lazy","handleErrorOrCompleted","treeRenderingInitiated","renderPromises","ssrDisabled","fetchDisabled","ssrLoading","addQueryPromise","prepareObservableQueryOptions","displayName","reactComponent","initializeObservableQuery","getSSRObservable","observableQueryOptions","registerSSRObservable","newObservableQueryOptions","resubscribeToQuery","observableQueryFields","partialRefetch","onCompleted","useBaseQuery","tick","updatedOptions","queryDataRef","queryData","memoFn","ref","useDeepMemo","queryResult","runMutation","mutationFunctionOptions","onMutationStart","mutationContext","ignoreResults","updateResult","initialize","getLoadingResult","shouldResubscribe","startSubscription","endSubscription","updateCurrentData","updateError","completeSubscription","onSubscriptionData","onSubscriptionComplete","queryPromises","queryInfoTrie","lookupQueryInfo","queryInstance","finish","hasPromises","consumeAndAwaitPromises","promises","promise","varMap","variablesString","mutationDataRef","mutationData","subscriptionDataRef","useSubscription","propTypes","isRequired","bool","number","oneOfType","arrayOf"],"mappings":"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","file":"static/js/5.631b341a.chunk.js","sourcesContent":["import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}","import React from 'react';\nimport ApolloClient from 'apollo-client';\n\nexport interface ApolloContextValue {\n  client?: ApolloClient<object>;\n  renderPromises?: Record<any, any>;\n}\n\nlet apolloContext: React.Context<ApolloContextValue>;\n\nexport function getApolloContext() {\n  if (!apolloContext) {\n    apolloContext = React.createContext<ApolloContextValue>({});\n  }\n  return apolloContext;\n}\n\nexport function resetApolloContext() {\n  apolloContext = React.createContext<ApolloContextValue>({});\n}\n","import {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode\n} from 'graphql';\nimport { invariant } from 'ts-invariant';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to saftey check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`\n  );\n\n  const fragments = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'FragmentDefinition'\n  );\n\n  const queries = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'query'\n  );\n\n  const mutations = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'mutation'\n  );\n\n  const subscriptions = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'subscription'\n  );\n\n  invariant(\n    !fragments.length ||\n      (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n","import React from 'react';\nimport ApolloClient from 'apollo-client';\nimport { invariant } from 'ts-invariant';\n\nimport { getApolloContext } from './ApolloContext';\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: React.ReactNode | React.ReactNode[] | null;\n}\n\nexport const ApolloProvider: React.FC<ApolloProviderProps<any>> = ({\n  client,\n  children\n}) => {\n  const ApolloContext = getApolloContext();\n  return (\n    <ApolloContext.Consumer>\n      {(context = {}) => {\n        if (client && context.client !== client) {\n          context = Object.assign({}, context, { client });\n        }\n\n        invariant(\n          context.client,\n          'ApolloProvider was not passed a client instance. Make ' +\n            'sure you pass in your client via the \"client\" prop.'\n        );\n\n        return (\n          <ApolloContext.Provider value={context}>\n            {children}\n          </ApolloContext.Provider>\n        );\n      }}\n    </ApolloContext.Consumer>\n  );\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","const genericMessage = \"Invariant Violation\";\nconst {\n  setPrototypeOf = function (obj: any, proto: any) {\n    obj.__proto__ = proto;\n    return obj;\n  },\n} = Object as any;\n\nexport class InvariantError extends Error {\n  framesToPop = 1;\n  name = genericMessage;\n  constructor(message: string | number = genericMessage) {\n    super(\n      typeof message === \"number\"\n        ? `${genericMessage}: ${message} (see https://github.com/apollographql/invariant-packages)`\n        : message\n    );\n    setPrototypeOf(this, InvariantError.prototype);\n  }\n}\n\nexport function invariant(condition: any, message?: string | number) {\n  if (!condition) {\n    throw new InvariantError(message);\n  }\n}\n\nfunction wrapConsoleMethod(method: \"warn\" | \"error\") {\n  return function () {\n    return console[method].apply(console, arguments as any);\n  } as (...args: any[]) => void;\n}\n\nexport namespace invariant {\n  export const warn = wrapConsoleMethod(\"warn\");\n  export const error = wrapConsoleMethod(\"error\");\n}\n\n// Code that uses ts-invariant with rollup-plugin-invariant may want to\n// import this process stub to avoid errors evaluating process.env.NODE_ENV.\n// However, because most ESM-to-CJS compilers will rewrite the process import\n// as tsInvariant.process, which prevents proper replacement by minifiers, we\n// also attempt to define the stub globally when it is not already defined.\nlet processStub: NodeJS.Process = { env: {} } as any;\nexport { processStub as process };\nif (typeof process === \"object\") {\n  processStub = process;\n} else try {\n  // Using Function to evaluate this assignment in global scope also escapes\n  // the strict mode of the current module, thereby allowing the assignment.\n  // Inspired by https://github.com/facebook/regenerator/pull/369.\n  Function(\"stub\", \"process = stub\")(processStub);\n} catch (atLeastWeTried) {\n  // The assignment can fail if a Content Security Policy heavy-handedly\n  // forbids Function usage. In those environments, developers should take\n  // extra care to replace process.env.NODE_ENV in their production builds,\n  // or define an appropriate global.process polyfill.\n}\n\nexport default invariant;\n","import {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n} from 'graphql';\n\nimport stringify from 'fast-json-stable-stringify';\nimport { InvariantError } from 'ts-invariant';\n\nexport interface IdValue {\n  type: 'id';\n  id: string;\n  generated: boolean;\n  typename: string | undefined;\n}\n\nexport interface JsonValue {\n  type: 'json';\n  json: any;\n}\n\nexport type ListValue = Array<null | IdValue>;\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | IdValue\n  | ListValue\n  | JsonValue\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport type ScalarValue = StringValueNode | BooleanValueNode | EnumValueNode;\n\nexport function isScalarValue(value: ValueNode): value is ScalarValue {\n  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\n\nexport type NumberValue = IntValueNode | FloatValueNode;\n\nexport function isNumberValue(value: ValueNode): value is NumberValue {\n  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object,\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map(obj =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables),\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(listValue => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables,\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw new InvariantError(\n      `The inline argument \"${name.value}\" of kind \"${(value as any).kind}\"` +\n        'is not supported. Use variables instead of inline arguments to ' +\n        'overcome this limitation.',\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object,\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(directive => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables,\n          ),\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  'connection',\n  'include',\n  'skip',\n  'client',\n  'rest',\n  'export',\n];\n\nexport function getStoreKeyName(\n  fieldName: string,\n  args?: Object,\n  directives?: Directives,\n): string {\n  if (\n    directives &&\n    directives['connection'] &&\n    directives['connection']['key']\n  ) {\n    if (\n      directives['connection']['filter'] &&\n      (directives['connection']['filter'] as string[]).length > 0\n    ) {\n      const filterKeys = directives['connection']['filter']\n        ? (directives['connection']['filter'] as string[])\n        : [];\n      filterKeys.sort();\n\n      const queryArgs = args as { [key: string]: any };\n      const filteredArgs = {} as { [key: string]: any };\n      filterKeys.forEach(key => {\n        filteredArgs[key] = queryArgs[key];\n      });\n\n      return `${directives['connection']['key']}(${JSON.stringify(\n        filteredArgs,\n      )})`;\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  let completeFieldName: string = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs: string = stringify(args);\n    completeFieldName += `(${stringifiedArgs})`;\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += `@${key}(${JSON.stringify(directives[key])})`;\n      } else {\n        completeFieldName += `@${key}`;\n      }\n    });\n  }\n\n  return completeFieldName;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables: Object,\n): Object {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n    return argObj;\n  }\n\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === 'Field';\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode,\n): selection is InlineFragmentNode {\n  return selection.kind === 'InlineFragment';\n}\n\nexport function isIdValue(idObject: StoreValue): idObject is IdValue {\n  return idObject &&\n    (idObject as IdValue | JsonValue).type === 'id' &&\n    typeof (idObject as IdValue).generated === 'boolean';\n}\n\nexport type IdConfig = {\n  id: string;\n  typename: string | undefined;\n};\n\nexport function toIdValue(\n  idConfig: string | IdConfig,\n  generated = false,\n): IdValue {\n  return {\n    type: 'id',\n    generated,\n    ...(typeof idConfig === 'string'\n      ? { id: idConfig, typename: undefined }\n      : idConfig),\n  };\n}\n\nexport function isJsonValue(jsonObject: StoreValue): jsonObject is JsonValue {\n  return (\n    jsonObject != null &&\n    typeof jsonObject === 'object' &&\n    (jsonObject as IdValue | JsonValue).type === 'json'\n  );\n}\n\nfunction defaultValueFromVariable(node: VariableNode) {\n  throw new InvariantError(`Variable nodes are not supported by valueFromNode`);\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n\n/**\n * Evaluate a ValueNode and yield its value in its natural JS form.\n */\nexport function valueFromNode(\n  node: ValueNode,\n  onVariable: VariableValue = defaultValueFromVariable,\n): any {\n  switch (node.kind) {\n    case 'Variable':\n      return onVariable(node);\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'ListValue':\n      return node.values.map(v => valueFromNode(v, onVariable));\n    case 'ObjectValue': {\n      const value: { [key: string]: any } = {};\n      for (const field of node.fields) {\n        value[field.name.value] = valueFromNode(field.value, onVariable);\n      }\n      return value;\n    }\n    default:\n      return node.value;\n  }\n}\n","// Provides the methods that allow QueryManager to handle the `skip` and\n// `include` directives within GraphQL.\nimport {\n  FieldNode,\n  SelectionNode,\n  VariableNode,\n  BooleanValueNode,\n  DirectiveNode,\n  DocumentNode,\n  ArgumentNode,\n  ValueNode,\n} from 'graphql';\n\nimport { visit } from 'graphql/language/visitor';\n\nimport { invariant } from 'ts-invariant';\n\nimport { argumentsObjectFromField } from './storeUtils';\n\nexport type DirectiveInfo = {\n  [fieldName: string]: { [argName: string]: any };\n};\n\nexport function getDirectiveInfoFromField(\n  field: FieldNode,\n  variables: Object,\n): DirectiveInfo {\n  if (field.directives && field.directives.length) {\n    const directiveObj: DirectiveInfo = {};\n    field.directives.forEach((directive: DirectiveNode) => {\n      directiveObj[directive.name.value] = argumentsObjectFromField(\n        directive,\n        variables,\n      );\n    });\n    return directiveObj;\n  }\n  return null;\n}\n\nexport function shouldInclude(\n  selection: SelectionNode,\n  variables: { [name: string]: any } = {},\n): boolean {\n  return getInclusionDirectives(\n    selection.directives,\n  ).every(({ directive, ifArgument }) => {\n    let evaledValue: boolean = false;\n    if (ifArgument.value.kind === 'Variable') {\n      evaledValue = variables[(ifArgument.value as VariableNode).name.value];\n      invariant(\n        evaledValue !== void 0,\n        `Invalid variable referenced in @${directive.name.value} directive.`,\n      );\n    } else {\n      evaledValue = (ifArgument.value as BooleanValueNode).value;\n    }\n    return directive.name.value === 'skip' ? !evaledValue : evaledValue;\n  });\n}\n\nexport function getDirectiveNames(doc: DocumentNode) {\n  const names: string[] = [];\n\n  visit(doc, {\n    Directive(node) {\n      names.push(node.name.value);\n    },\n  });\n\n  return names;\n}\n\nexport function hasDirectives(names: string[], doc: DocumentNode) {\n  return getDirectiveNames(doc).some(\n    (name: string) => names.indexOf(name) > -1,\n  );\n}\n\nexport function hasClientExports(document: DocumentNode) {\n  return (\n    document &&\n    hasDirectives(['client'], document) &&\n    hasDirectives(['export'], document)\n  );\n}\n\nexport type InclusionDirectives = Array<{\n  directive: DirectiveNode;\n  ifArgument: ArgumentNode;\n}>;\n\nfunction isInclusionDirective({ name: { value } }: DirectiveNode): boolean {\n  return value === 'skip' || value === 'include';\n}\n\nexport function getInclusionDirectives(\n  directives: ReadonlyArray<DirectiveNode>,\n): InclusionDirectives {\n  return directives ? directives.filter(isInclusionDirective).map(directive => {\n    const directiveArguments = directive.arguments;\n    const directiveName = directive.name.value;\n\n    invariant(\n      directiveArguments && directiveArguments.length === 1,\n      `Incorrect number of arguments for the @${directiveName} directive.`,\n    );\n\n    const ifArgument = directiveArguments[0];\n    invariant(\n      ifArgument.name && ifArgument.name.value === 'if',\n      `Invalid argument for the @${directiveName} directive.`,\n    );\n\n    const ifValue: ValueNode = ifArgument.value;\n\n    // means it has to be a variable value if this is a valid @skip or @include directive\n    invariant(\n      ifValue &&\n        (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'),\n      `Argument for the @${directiveName} directive must be a variable or a boolean value.`,\n    );\n\n    return { directive, ifArgument };\n  }) : [];\n}\n\n","import { DocumentNode, FragmentDefinitionNode } from 'graphql';\nimport { invariant, InvariantError } from 'ts-invariant';\n\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(\n  document: DocumentNode,\n  fragmentName?: string,\n): DocumentNode {\n  let actualFragmentName = fragmentName;\n\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments: Array<FragmentDefinitionNode> = [];\n  document.definitions.forEach(definition => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === 'OperationDefinition') {\n      throw new InvariantError(\n        `Found a ${definition.operation} operation${\n          definition.name ? ` named '${definition.name.value}'` : ''\n        }. ` +\n          'No operations are allowed when using a fragment as a query. Only fragments are allowed.',\n      );\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === 'FragmentDefinition') {\n      fragments.push(definition);\n    }\n  });\n\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === 'undefined') {\n    invariant(\n      fragments.length === 1,\n      `Found ${\n        fragments.length\n      } fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n    );\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query: DocumentNode = {\n    ...document,\n    definitions: [\n      {\n        kind: 'OperationDefinition',\n        operation: 'query',\n        selectionSet: {\n          kind: 'SelectionSet',\n          selections: [\n            {\n              kind: 'FragmentSpread',\n              name: {\n                kind: 'Name',\n                value: actualFragmentName,\n              },\n            },\n          ],\n        },\n      },\n      ...document.definitions,\n    ],\n  };\n\n  return query;\n}\n","/**\n * Adds the properties of one or more source objects to a target object. Works exactly like\n * `Object.assign`, but as a utility to maintain support for IE 11.\n *\n * @see https://github.com/apollostack/apollo-client/pull/1009\n */\nexport function assign<A, B>(a: A, b: B): A & B;\nexport function assign<A, B, C>(a: A, b: B, c: C): A & B & C;\nexport function assign<A, B, C, D>(a: A, b: B, c: C, d: D): A & B & C & D;\nexport function assign<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n): A & B & C & D & E;\nexport function assign(target: any, ...sources: Array<any>): any;\nexport function assign(\n  target: { [key: string]: any },\n  ...sources: Array<{ [key: string]: any }>\n): { [key: string]: any } {\n  sources.forEach(source => {\n    if (typeof source === 'undefined' || source === null) {\n      return;\n    }\n    Object.keys(source).forEach(key => {\n      target[key] = source[key];\n    });\n  });\n  return target;\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from 'graphql';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { assign } from './util/assign';\n\nimport { valueToObjectRepresentation, JsonValue } from './storeUtils';\n\nexport function getMutationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode {\n  checkDocument(doc);\n\n  let mutationDef: OperationDefinitionNode | null = doc.definitions.filter(\n    definition =>\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'mutation',\n  )[0] as OperationDefinitionNode;\n\n  invariant(mutationDef, 'Must contain a mutation definition.');\n\n  return mutationDef;\n}\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  invariant(\n    doc && doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  const operations = doc.definitions\n    .filter(d => d.kind !== 'FragmentDefinition')\n    .map(definition => {\n      if (definition.kind !== 'OperationDefinition') {\n        throw new InvariantError(\n          `Schema type definitions not allowed in queries. Found: \"${\n            definition.kind\n          }\"`,\n        );\n      }\n      return definition;\n    });\n\n  invariant(\n    operations.length <= 1,\n    `Ambiguous GraphQL document: contains ${operations.length} operations`,\n  );\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    definition => definition.kind === 'OperationDefinition',\n  )[0] as OperationDefinitionNode;\n}\n\nexport function getOperationDefinitionOrDie(\n  document: DocumentNode,\n): OperationDefinitionNode {\n  const def = getOperationDefinition(document);\n  invariant(def, `GraphQL document is missing an operation`);\n  return def;\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        definition =>\n          definition.kind === 'OperationDefinition' && definition.name,\n      )\n      .map((x: OperationDefinitionNode) => x.name.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode,\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    definition => definition.kind === 'FragmentDefinition',\n  ) as FragmentDefinitionNode[];\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc) as OperationDefinitionNode;\n\n  invariant(\n    queryDef && queryDef.operation === 'query',\n    'Must contain a query definition.',\n  );\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode,\n): FragmentDefinitionNode {\n  invariant(\n    doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  invariant(\n    doc.definitions.length <= 1,\n    'Fragment must have exactly one definition.',\n  );\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  invariant(\n    fragmentDef.kind === 'FragmentDefinition',\n    'Must be a fragment definition.',\n  );\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode,\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === 'query' ||\n        operation === 'mutation' ||\n        operation === 'subscription'\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new InvariantError(\n    'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.',\n  );\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = [],\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach(fragment => {\n    symTable[fragment.name.value] = fragment;\n  });\n\n  return symTable;\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined,\n): { [key: string]: JsonValue } {\n  if (\n    definition &&\n    definition.variableDefinitions &&\n    definition.variableDefinitions.length\n  ) {\n    const defaultValues = definition.variableDefinitions\n      .filter(({ defaultValue }) => defaultValue)\n      .map(\n        ({ variable, defaultValue }): { [key: string]: JsonValue } => {\n          const defaultValueObj: { [key: string]: JsonValue } = {};\n          valueToObjectRepresentation(\n            defaultValueObj,\n            variable.name,\n            defaultValue as ValueNode,\n          );\n\n          return defaultValueObj;\n        },\n      );\n\n    return assign({}, ...defaultValues);\n  }\n\n  return {};\n}\n\n/**\n * Returns the names of all variables declared by the operation.\n */\nexport function variablesInOperation(\n  operation: OperationDefinitionNode,\n): Set<string> {\n  const names = new Set<string>();\n  if (operation.variableDefinitions) {\n    for (const definition of operation.variableDefinitions) {\n      names.add(definition.variable.name.value);\n    }\n  }\n\n  return names;\n}\n","export function filterInPlace<T>(\n  array: T[],\n  test: (elem: T) => boolean,\n  context?: any,\n): T[] {\n  let target = 0;\n  array.forEach(function (elem, i) {\n    if (test.call(this, elem, i, array)) {\n      array[target++] = elem;\n    }\n  }, context);\n  array.length = target;\n  return array;\n}\n","import {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  VariableNode,\n} from 'graphql';\nimport { visit } from 'graphql/language/visitor';\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n  getMainDefinition,\n} from './getFromAST';\nimport { filterInPlace } from './util/filterInPlace';\nimport { invariant } from 'ts-invariant';\nimport { isField, isInlineFragment } from './storeUtils';\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig = RemoveNodeConfig<\n  FragmentDefinitionNode\n>;\nexport type RemoveVariableDefinitionConfig = RemoveNodeConfig<\n  VariableDefinitionNode\n>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field',\n  name: {\n    kind: 'Name',\n    value: '__typename',\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragments: FragmentMap,\n): boolean {\n  return op.selectionSet.selections.every(\n    selection =>\n      selection.kind === 'FragmentSpread' &&\n      isEmpty(fragments[selection.name.value], fragments),\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinition(doc) || getFragmentDefinition(doc),\n    createFragmentMap(getFragmentDefinitions(doc)),\n  )\n    ? null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode) {\n    return directives.some(\n      dir =>\n        (dir.name && dir.name === directive.name.value) ||\n        (dir.test && dir.test(directive)),\n    );\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const variablesInUse: Record<string, boolean> = Object.create(null);\n  let variablesToRemove: RemoveArgumentsConfig[] = [];\n\n  const fragmentSpreadsInUse: Record<string, boolean> = Object.create(null);\n  let fragmentSpreadsToRemove: RemoveFragmentSpreadConfig[] = [];\n\n  let modifiedDoc = nullIfDocIsEmpty(\n    visit(doc, {\n      Variable: {\n        enter(node, _key, parent) {\n          // Store each variable that's referenced as part of an argument\n          // (excluding operation definition variables), so we know which\n          // variables are being used. If we later want to remove a variable\n          // we'll fist check to see if it's being used, before continuing with\n          // the removal.\n          if (\n            (parent as VariableDefinitionNode).kind !== 'VariableDefinition'\n          ) {\n            variablesInUse[node.name.value] = true;\n          }\n        },\n      },\n\n      Field: {\n        enter(node) {\n          if (directives && node.directives) {\n            // If `remove` is set to true for a directive, and a directive match\n            // is found for a field, remove the field as well.\n            const shouldRemoveField = directives.some(\n              directive => directive.remove,\n            );\n\n            if (\n              shouldRemoveField &&\n              node.directives &&\n              node.directives.some(getDirectiveMatcher(directives))\n            ) {\n              if (node.arguments) {\n                // Store field argument variables so they can be removed\n                // from the operation definition.\n                node.arguments.forEach(arg => {\n                  if (arg.value.kind === 'Variable') {\n                    variablesToRemove.push({\n                      name: (arg.value as VariableNode).name.value,\n                    });\n                  }\n                });\n              }\n\n              if (node.selectionSet) {\n                // Store fragment spread names so they can be removed from the\n                // docuemnt.\n                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(\n                  frag => {\n                    fragmentSpreadsToRemove.push({\n                      name: frag.name.value,\n                    });\n                  },\n                );\n              }\n\n              // Remove the field.\n              return null;\n            }\n          }\n        },\n      },\n\n      FragmentSpread: {\n        enter(node) {\n          // Keep track of referenced fragment spreads. This is used to\n          // determine if top level fragment definitions should be removed.\n          fragmentSpreadsInUse[node.name.value] = true;\n        },\n      },\n\n      Directive: {\n        enter(node) {\n          // If a matching directive is found, remove it.\n          if (getDirectiveMatcher(directives)(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n\n  // If we've removed fields with arguments, make sure the associated\n  // variables are also removed from the rest of the document, as long as they\n  // aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(variablesToRemove, v => !variablesInUse[v.name]).length\n  ) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  // If we've removed selection sets with fragment spreads, make sure the\n  // associated fragment definitions are also removed from the rest of the\n  // document, as long as they aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(fragmentSpreadsToRemove, fs => !fragmentSpreadsInUse[fs.name])\n      .length\n  ) {\n    modifiedDoc = removeFragmentSpreadFromDocument(\n      fragmentSpreadsToRemove,\n      modifiedDoc,\n    );\n  }\n\n  return modifiedDoc;\n}\n\nexport function addTypenameToDocument(doc: DocumentNode): DocumentNode {\n  return visit(checkDocument(doc), {\n    SelectionSet: {\n      enter(node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (\n          parent &&\n          (parent as OperationDefinitionNode).kind === 'OperationDefinition'\n        ) {\n          return;\n        }\n\n        // No changes if no selections.\n        const { selections } = node;\n        if (!selections) {\n          return;\n        }\n\n        // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n        const skip = selections.some(selection => {\n          return (\n            isField(selection) &&\n            (selection.name.value === '__typename' ||\n              selection.name.value.lastIndexOf('__', 0) === 0)\n          );\n        });\n        if (skip) {\n          return;\n        }\n\n        // If this SelectionSet is @export-ed as an input variable, it should\n        // not have a __typename field (see issue #4691).\n        const field = parent as FieldNode;\n        if (\n          isField(field) &&\n          field.directives &&\n          field.directives.some(d => d.name.value === 'export')\n        ) {\n          return;\n        }\n\n        // Create and return a new SelectionSet with a __typename Field.\n        return {\n          ...node,\n          selections: [...selections, TYPENAME_FIELD],\n        };\n      },\n    },\n  });\n}\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        invariant.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc),\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n  nestedCheck = true,\n): boolean {\n  return (\n    selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some(selection =>\n      hasDirectivesInSelection(directives, selection, nestedCheck),\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nexport function getDirectivesFromDocument(\n  directives: GetDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  checkDocument(doc);\n\n  let parentPath: string;\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      SelectionSet: {\n        enter(node, _key, _parent, path) {\n          const currentPath = path.join('-');\n\n          if (\n            !parentPath ||\n            currentPath === parentPath ||\n            !currentPath.startsWith(parentPath)\n          ) {\n            if (node.selections) {\n              const selectionsWithDirectives = node.selections.filter(\n                selection => hasDirectivesInSelection(directives, selection),\n              );\n\n              if (hasDirectivesInSelectionSet(directives, node, false)) {\n                parentPath = currentPath;\n              }\n\n              return {\n                ...node,\n                selections: selectionsWithDirectives,\n              };\n            } else {\n              return null;\n            }\n          }\n        },\n      },\n    }),\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === 'Variable' &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument))),\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions: node.variableDefinitions.filter(\n              varDef =>\n                !config.some(arg => arg.name === varDef.variable.name.value),\n            ),\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(argConfig => argConfig.remove);\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            node.arguments.forEach(arg => {\n              if (argMatcher(arg)) {\n                argMatchCount += 1;\n              }\n            });\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode,\n  ): null | void {\n    if (config.some(def => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    }),\n  );\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(\n  selectionSet: SelectionSetNode,\n): FragmentSpreadNode[] {\n  const allFragments: FragmentSpreadNode[] = [];\n\n  selectionSet.selections.forEach(selection => {\n    if (\n      (isField(selection) || isInlineFragment(selection)) &&\n      selection.selectionSet\n    ) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(\n        frag => allFragments.push(frag),\n      );\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n\n  return allFragments;\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode,\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === 'query') {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: 'query',\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode,\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === 'client',\n        remove: true,\n      },\n    ],\n    document,\n  );\n\n  // After a fragment definition has had its @client related document\n  // sets removed, if the only field it has left is a __typename field,\n  // remove the entire fragment operation to prevent it from being fired\n  // on the server.\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter(node) {\n          if (node.selectionSet) {\n            const isTypenameOnly = node.selectionSet.selections.every(\n              selection =>\n                isField(selection) && selection.name.value === '__typename',\n            );\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        },\n      },\n    });\n  }\n\n  return modifiedDoc;\n}\n","export const canUseWeakMap = typeof WeakMap === 'function' && !(\n  typeof navigator === 'object' &&\n  navigator.product === 'ReactNative'\n);\n","const { toString } = Object.prototype;\n\n/**\n * Deeply clones a value to create a new instance.\n */\nexport function cloneDeep<T>(value: T): T {\n  return cloneDeepHelper(value, new Map());\n}\n\nfunction cloneDeepHelper<T>(val: T, seen: Map<any, any>): T {\n  switch (toString.call(val)) {\n  case \"[object Array]\": {\n    if (seen.has(val)) return seen.get(val);\n    const copy: T & any[] = (val as any).slice(0);\n    seen.set(val, copy);\n    copy.forEach(function (child, i) {\n      copy[i] = cloneDeepHelper(child, seen);\n    });\n    return copy;\n  }\n\n  case \"[object Object]\": {\n    if (seen.has(val)) return seen.get(val);\n    // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n    // possible in all JS environments, so we will assume they exist/work.\n    const copy = Object.create(Object.getPrototypeOf(val));\n    seen.set(val, copy);\n    Object.keys(val).forEach(key => {\n      copy[key] = cloneDeepHelper((val as any)[key], seen);\n    });\n    return copy;\n  }\n\n  default:\n    return val;\n  }\n}\n","export function getEnv(): string | undefined {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV) {\n    return process.env.NODE_ENV;\n  }\n\n  // default environment\n  return 'development';\n}\n\nexport function isEnv(env: string): boolean {\n  return getEnv() === env;\n}\n\nexport function isProduction(): boolean {\n  return isEnv('production') === true;\n}\n\nexport function isDevelopment(): boolean {\n  return isEnv('development') === true;\n}\n\nexport function isTest(): boolean {\n  return isEnv('test') === true;\n}\n","import { ExecutionResult } from 'graphql';\n\nexport function tryFunctionOrLogError(f: Function) {\n  try {\n    return f();\n  } catch (e) {\n    if (console.error) {\n      console.error(e);\n    }\n  }\n}\n\nexport function graphQLResultHasError(result: ExecutionResult) {\n  return result.errors && result.errors.length;\n}\n","import { isDevelopment, isTest } from './environment';\n\n// Taken (mostly) from https://github.com/substack/deep-freeze to avoid\n// import hassles with rollup.\nfunction deepFreeze(o: any) {\n  Object.freeze(o);\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n}\n\nexport function maybeDeepFreeze(obj: any) {\n  if (isDevelopment() || isTest()) {\n    // Polyfilled Symbols potentially cause infinite / very deep recursion while deep freezing\n    // which is known to crash IE11 (https://github.com/apollographql/apollo-client/issues/3043).\n    const symbolIsPolyfilled =\n      typeof Symbol === 'function' && typeof Symbol('') === 'string';\n\n    if (!symbolIsPolyfilled) {\n      return deepFreeze(obj);\n    }\n  }\n  return obj;\n}\n","const { hasOwnProperty } = Object.prototype;\n\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\nexport type TupleToIntersection<T extends any[]> =\n  T extends [infer A] ? A :\n  T extends [infer A, infer B] ? A & B :\n  T extends [infer A, infer B, infer C] ? A & B & C :\n  T extends [infer A, infer B, infer C, infer D] ? A & B & C & D :\n  T extends [infer A, infer B, infer C, infer D, infer E] ? A & B & C & D & E :\n  T extends (infer U)[] ? U : any;\n\nexport function mergeDeep<T extends any[]>(\n  ...sources: T\n): TupleToIntersection<T> {\n  return mergeDeepArray(sources);\n}\n\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray<T>(sources: T[]): T {\n  let target = sources[0] || {} as T;\n  const count = sources.length;\n  if (count > 1) {\n    const pastCopies: any[] = [];\n    target = shallowCopyForMerge(target, pastCopies);\n    for (let i = 1; i < count; ++i) {\n      target = mergeHelper(target, sources[i], pastCopies);\n    }\n  }\n  return target;\n}\n\nfunction isObject(obj: any): obj is Record<string | number, any> {\n  return obj !== null && typeof obj === 'object';\n}\n\nfunction mergeHelper(\n  target: any,\n  source: any,\n  pastCopies: any[],\n) {\n  if (isObject(source) && isObject(target)) {\n    // In case the target has been frozen, make an extensible copy so that\n    // we can merge properties into the copy.\n    if (Object.isExtensible && !Object.isExtensible(target)) {\n      target = shallowCopyForMerge(target, pastCopies);\n    }\n\n    Object.keys(source).forEach(sourceKey => {\n      const sourceValue = source[sourceKey];\n      if (hasOwnProperty.call(target, sourceKey)) {\n        const targetValue = target[sourceKey];\n        if (sourceValue !== targetValue) {\n          // When there is a key collision, we need to make a shallow copy of\n          // target[sourceKey] so the merge does not modify any source objects.\n          // To avoid making unnecessary copies, we use a simple array to track\n          // past copies, since it's safe to modify copies created earlier in\n          // the merge. We use an array for pastCopies instead of a Map or Set,\n          // since the number of copies should be relatively small, and some\n          // Map/Set polyfills modify their keys.\n          target[sourceKey] = mergeHelper(\n            shallowCopyForMerge(targetValue, pastCopies),\n            sourceValue,\n            pastCopies,\n          );\n        }\n      } else {\n        // If there is no collision, the target can safely share memory with\n        // the source, and the recursion can terminate here.\n        target[sourceKey] = sourceValue;\n      }\n    });\n\n    return target;\n  }\n\n  // If source (or target) is not an object, let source replace target.\n  return source;\n}\n\nfunction shallowCopyForMerge<T>(value: T, pastCopies: any[]): T {\n  if (\n    value !== null &&\n    typeof value === 'object' &&\n    pastCopies.indexOf(value) < 0\n  ) {\n    if (Array.isArray(value)) {\n      value = (value as any).slice(0);\n    } else {\n      value = {\n        __proto__: Object.getPrototypeOf(value),\n        ...value,\n      };\n    }\n    pastCopies.push(value);\n  }\n  return value;\n}\n","import { isProduction, isTest } from './environment';\n\nconst haveWarned = Object.create({});\n\n/**\n * Print a warning only once in development.\n * In production no warnings are printed.\n * In test all warnings are printed.\n *\n * @param msg The warning message\n * @param type warn or error (will call console.warn or console.error)\n */\nexport function warnOnceInDevelopment(msg: string, type = 'warn') {\n  if (!isProduction() && !haveWarned[msg]) {\n    if (!isTest()) {\n      haveWarned[msg] = true;\n    }\n    if (type === 'error') {\n      console.error(msg);\n    } else {\n      console.warn(msg);\n    }\n  }\n}\n","/**\n * The current status of a querys execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus: NetworkStatus,\n): boolean {\n  return networkStatus < 7;\n}\n","// This simplified polyfill attempts to follow the ECMAScript Observable proposal.\n// See https://github.com/zenparsing/es-observable\nimport { Observable as LinkObservable } from 'apollo-link';\n\nexport type Subscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\nimport $$observable from 'symbol-observable';\n\n// rxjs interopt\nexport class Observable<T> extends LinkObservable<T> {\n  public [$$observable]() {\n    return this;\n  }\n\n  public ['@@observable' as any]() {\n    return this;\n  }\n}\n","export function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T> {\n  return Array.isArray(value) && value.length > 0;\n}\n","import { GraphQLError } from 'graphql';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  let message = '';\n  // If we have GraphQL errors present, add that to the error message.\n  if (isNonEmptyArray(err.graphQLErrors)) {\n    err.graphQLErrors.forEach((graphQLError: GraphQLError) => {\n      const errorMessage = graphQLError\n        ? graphQLError.message\n        : 'Error message not found.';\n      message += `GraphQL error: ${errorMessage}\\n`;\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  // strip newline from the end of the message\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nexport class ApolloError extends Error {\n  public message: string;\n  public graphQLErrors: ReadonlyArray<GraphQLError>;\n  public networkError: Error | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: {\n    graphQLErrors?: ReadonlyArray<GraphQLError>;\n    networkError?: Error | null;\n    errorMessage?: string;\n    extraInfo?: any;\n  }) {\n    super(errorMessage);\n    this.graphQLErrors = graphQLErrors || [];\n    this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      this.message = generateErrorMessage(this);\n    } else {\n      this.message = errorMessage;\n    }\n\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n","import { FetchResult } from 'apollo-link';\nimport { DocumentNode, GraphQLError } from 'graphql';\n\nimport { QueryStoreValue } from '../data/queries';\nimport { NetworkStatus } from './networkStatus';\nimport { Resolver } from './LocalState';\n\nexport type QueryListener = (\n  queryStoreValue: QueryStoreValue,\n  newData?: any,\n  forceResolvers?: boolean,\n) => void;\n\nexport type OperationVariables = { [key: string]: any };\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n  context?: any;\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  stale: boolean;\n};\n\nexport enum FetchType {\n  normal = 1,\n  refetch = 2,\n  poll = 3,\n}\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n\nexport interface Resolvers {\n  [key: string]: {\n    [ field: string ]: Resolver;\n  };\n}\n","import {\n  isEqual,\n  tryFunctionOrLogError,\n  cloneDeep,\n  getOperationDefinition,\n} from 'apollo-utilities';\nimport { GraphQLError } from 'graphql';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { Observable, Observer, Subscription } from '../util/Observable';\nimport { ApolloError } from '../errors/ApolloError';\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, FetchType, OperationVariables } from './types';\nimport {\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\n\nimport { QueryStoreValue } from '../data/queries';\n\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { isNonEmptyArray } from '../util/arrays';\n\n// XXX remove in the next breaking semver change (3.0)\n// Deprecated, use ApolloCurrentQueryResult\nexport type ApolloCurrentResult<T> = {\n  data: T | {};\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n};\n\nexport type ApolloCurrentQueryResult<T> = {\n  data: T | undefined;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n  stale?: boolean;\n};\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables\n> {\n  updateQuery: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    },\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\nexport const hasError = (\n  storeValue: QueryStoreValue,\n  policy: ErrorPolicy = 'none',\n) => storeValue && (\n  storeValue.networkError ||\n  (policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors))\n);\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables = OperationVariables\n> extends Observable<ApolloQueryResult<TData>> {\n  public options: WatchQueryOptions<TVariables>;\n  public readonly queryId: string;\n  public readonly queryName?: string;\n  /**\n   *\n   * The current value of the variables for this query. Can change.\n   */\n  public variables: TVariables;\n\n  private shouldSubscribe: boolean;\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers = new Set<Observer<ApolloQueryResult<TData>>>();\n  private subscriptions = new Set<Subscription>();\n\n  private lastResult: ApolloQueryResult<TData>;\n  private lastResultSnapshot: ApolloQueryResult<TData>;\n  private lastError: ApolloError;\n\n  constructor({\n    queryManager,\n    options,\n    shouldSubscribe = true,\n  }: {\n    queryManager: QueryManager<any>;\n    options: WatchQueryOptions<TVariables>;\n    shouldSubscribe?: boolean;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) =>\n      this.onSubscribe(observer),\n    );\n\n    // active state\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.variables = options.variables || ({} as TVariables);\n    this.queryId = queryManager.generateQueryId();\n    this.shouldSubscribe = shouldSubscribe;\n\n    const opDef = getOperationDefinition(options.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n\n    // related classes\n    this.queryManager = queryManager;\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    return new Promise((resolve, reject) => {\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next: (result: ApolloQueryResult<TData>) => {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          this.observers.delete(observer);\n          if (!this.observers.size) {\n            this.queryManager.removeQuery(this.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject,\n      };\n      const subscription = this.subscribe(observer);\n    });\n  }\n\n  // XXX remove in the next breaking semver change (3.0)\n  // Deprecated, use getCurrentResult()\n  public currentResult(): ApolloCurrentResult<TData> {\n    const result = this.getCurrentResult() as ApolloCurrentResult<TData>;\n    if (result.data === undefined) {\n      result.data = {};\n    }\n    return result;\n  }\n\n  /**\n   * Return the result of the query from the local cache as well as some fetching status\n   * `loading` and `networkStatus` allow to know if a request is in flight\n   * `partial` lets you know if the result from the local cache is complete or partial\n   * @return {data: Object, error: ApolloError, loading: boolean, networkStatus: number, partial: boolean}\n   */\n  public getCurrentResult(): ApolloCurrentQueryResult<TData> {\n    if (this.isTornDown) {\n      const { lastResult } = this;\n      return {\n        data: !this.lastError && lastResult && lastResult.data || void 0,\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      };\n    }\n\n    const { data, partial } = this.queryManager.getCurrentQueryResult(this);\n    const queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n    let result: ApolloQueryResult<TData>;\n\n    const { fetchPolicy } = this.options;\n\n    const isNetworkFetchPolicy =\n      fetchPolicy === 'network-only' ||\n      fetchPolicy === 'no-cache';\n\n    if (queryStoreValue) {\n      const { networkStatus } = queryStoreValue;\n\n      if (hasError(queryStoreValue, this.options.errorPolicy)) {\n        return {\n          data: void 0,\n          loading: false,\n          networkStatus,\n          error: new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError,\n          }),\n        };\n      }\n\n      // Variables might have been added dynamically at query time, when\n      // using `@client @export(as: \"varname\")` for example. When this happens,\n      // the variables have been updated in the query store, but not updated on\n      // the original `ObservableQuery`. We'll update the observable query\n      // variables here to match, so retrieving from the cache doesn't fail.\n      if (queryStoreValue.variables) {\n        this.options.variables = {\n          ...this.options.variables,\n          ...(queryStoreValue.variables as TVariables),\n        };\n        this.variables = this.options.variables;\n      }\n\n      result = {\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n      } as ApolloQueryResult<TData>;\n\n      if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {\n        result.errors = queryStoreValue.graphQLErrors;\n      }\n\n    } else {\n      // We need to be careful about the loading state we show to the user, to try\n      // and be vaguely in line with what the user would have seen from .subscribe()\n      // but to still provide useful information synchronously when the query\n      // will not end up hitting the server.\n      // See more: https://github.com/apollostack/apollo-client/issues/707\n      // Basically: is there a query in flight right now (modolo the next tick)?\n      const loading = isNetworkFetchPolicy ||\n        (partial && fetchPolicy !== 'cache-only');\n\n      result = {\n        data,\n        loading,\n        networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready,\n      } as ApolloQueryResult<TData>;\n    }\n\n    if (!partial) {\n      this.updateLastResult({ ...result, stale: false });\n    }\n\n    return { ...result, partial };\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(newResult: ApolloQueryResult<TData>) {\n    const { lastResultSnapshot: snapshot } = this;\n    return !(\n      snapshot &&\n      newResult &&\n      snapshot.networkStatus === newResult.networkStatus &&\n      snapshot.stale === newResult.stale &&\n      isEqual(snapshot.data, newResult.data)\n    );\n  }\n\n  // Returns the last result that observer.next was called with. This is not the same as\n  // getCurrentResult! If you're not sure which you need, then you probably need getCurrentResult.\n  public getLastResult(): ApolloQueryResult<TData> {\n    return this.lastResult;\n  }\n\n  public getLastError(): ApolloError {\n    return this.lastError;\n  }\n\n  public resetLastResults(): void {\n    delete this.lastResult;\n    delete this.lastResultSnapshot;\n    delete this.lastError;\n    this.isTornDown = false;\n  }\n\n  public resetQueryStoreErrors() {\n    const queryStore = this.queryManager.queryStore.get(this.queryId);\n    if (queryStore) {\n      queryStore.networkError = null;\n      queryStore.graphQLErrors = [];\n    }\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(variables?: TVariables): Promise<ApolloQueryResult<TData>> {\n    let { fetchPolicy } = this.options;\n    // early return if trying to read from cache during refetch\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(new InvariantError(\n        'cache-only fetchPolicy option should not be used together with query refetch.',\n      ));\n    }\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy !== 'no-cache' &&\n        fetchPolicy !== 'cache-and-network') {\n      fetchPolicy = 'network-only';\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      // update observable variables\n      this.variables = {\n        ...this.variables,\n        ...variables,\n      };\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      // Update the existing options with new variables\n      this.options.variables = {\n        ...this.options.variables,\n        ...this.variables,\n      };\n    }\n\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      { ...this.options, fetchPolicy },\n      FetchType.refetch,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public fetchMore<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>,\n  ): Promise<ApolloQueryResult<TData>> {\n    // early return if no update Query\n    invariant(\n      fetchMoreOptions.updateQuery,\n      'updateQuery option is required. This function defines how to update the query data with the new results.',\n    );\n\n    const combinedOptions = {\n      ...(fetchMoreOptions.query ? fetchMoreOptions : {\n        ...this.options,\n        ...fetchMoreOptions,\n        variables: {\n          ...this.variables,\n          ...fetchMoreOptions.variables,\n        },\n      }),\n      fetchPolicy: 'network-only',\n    } as WatchQueryOptions;\n\n    const qid = this.queryManager.generateQueryId();\n\n    return this.queryManager\n      .fetchQuery(\n        qid,\n        combinedOptions,\n        FetchType.normal,\n        this.queryId,\n      )\n      .then(\n        fetchMoreResult => {\n          this.updateQuery((previousResult: any) =>\n            fetchMoreOptions.updateQuery(previousResult, {\n              fetchMoreResult: fetchMoreResult.data as TData,\n              variables: combinedOptions.variables as TVariables,\n            }),\n          );\n          this.queryManager.stopQuery(qid);\n          return fetchMoreResult as ApolloQueryResult<TData>;\n        },\n        error => {\n          this.queryManager.stopQuery(qid);\n          throw error;\n        },\n      );\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >,\n  ) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TSubscriptionData }) => {\n          const { updateQuery } = options;\n          if (updateQuery) {\n            this.updateQuery<TSubscriptionVariables>(\n              (previous, { variables }) =>\n                updateQuery(previous, {\n                  subscriptionData,\n                  variables,\n                }),\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          invariant.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  // Note: if the query is not active (there are no subscribers), the promise\n  // will return null immediately.\n  public setOptions(\n    opts: WatchQueryOptions,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    const { fetchPolicy: oldFetchPolicy } = this.options;\n    this.options = {\n      ...this.options,\n      ...opts,\n    } as WatchQueryOptions<TVariables>;\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    const { fetchPolicy } = opts;\n\n    return this.setVariables(\n      this.options.variables as TVariables,\n      // Try to fetch the query if fetchPolicy changed from either cache-only\n      // or standby to something else, or changed to network-only.\n      oldFetchPolicy !== fetchPolicy && (\n        oldFetchPolicy === 'cache-only' ||\n        oldFetchPolicy === 'standby' ||\n        fetchPolicy === 'network-only'\n      ),\n      opts.fetchResults,\n    );\n  }\n\n  /**\n   * This is for *internal* use only. Most users should instead use `refetch`\n   * in order to be properly notified of results even when they come from cache.\n   *\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   *\n   * @param tryFetch: Try and fetch new results even if the variables haven't\n   * changed (we may still just hit the store, but if there's nothing in there\n   * this will refetch)\n   *\n   * @param fetchResults: Option to ignore fetching results when updating variables\n   */\n  public setVariables(\n    variables: TVariables,\n    tryFetch: boolean = false,\n    fetchResults = true,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    // since setVariables restarts the subscription, we reset the tornDown status\n    this.isTornDown = false;\n\n    variables = variables || this.variables;\n\n    if (!tryFetch && isEqual(variables, this.variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size && fetchResults\n        ? this.result()\n        : Promise.resolve();\n    }\n\n    this.variables = this.options.variables = variables;\n\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    // Use the same options as before, but with new variables\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      this.options,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public updateQuery<TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>,\n    ) => TData,\n  ): void {\n    const { queryManager } = this;\n    const {\n      previousResult,\n      variables,\n      document,\n    } = queryManager.getQueryWithPreviousResult<TData, TVars>(\n      this.queryId,\n    );\n\n    const newResult = tryFunctionOrLogError(() =>\n      mapFn(previousResult, { variables }),\n    );\n\n    if (newResult) {\n      queryManager.dataStore.markUpdateQueryResult(\n        document,\n        variables,\n        newResult,\n      );\n      queryManager.broadcastQueries();\n    }\n  }\n\n  public stopPolling() {\n    this.queryManager.stopPollingQuery(this.queryId);\n    this.options.pollInterval = undefined;\n  }\n\n  public startPolling(pollInterval: number) {\n    assertNotCacheFirstOrOnly(this);\n    this.options.pollInterval = pollInterval;\n    this.queryManager.startPollingQuery(this.options, this.queryId);\n  }\n\n  private updateLastResult(newResult: ApolloQueryResult<TData>) {\n    const previousResult = this.lastResult;\n    this.lastResult = newResult;\n    this.lastResultSnapshot = this.queryManager.assumeImmutableResults\n      ? newResult\n      : cloneDeep(newResult);\n    return previousResult;\n  }\n\n  private onSubscribe(observer: Observer<ApolloQueryResult<TData>>) {\n    // Zen Observable has its own error function, so in order to log correctly\n    // we need to provide a custom error callback.\n    try {\n      var subObserver = (observer as any)._subscription._observer;\n      if (subObserver && !subObserver.error) {\n        subObserver.error = defaultSubscriptionObserverErrorCallback;\n      }\n    } catch {}\n\n    const first = !this.observers.size;\n    this.observers.add(observer);\n\n    // Deliver initial result\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    // setup the query if it hasn't been done before\n    if (first) {\n      this.setUpQuery();\n    }\n\n    return () => {\n      if (this.observers.delete(observer) && !this.observers.size) {\n        this.tearDownQuery();\n      }\n    };\n  }\n\n  private setUpQuery() {\n    const { queryManager, queryId } = this;\n\n    if (this.shouldSubscribe) {\n      queryManager.addObservableQuery<TData>(queryId, this);\n    }\n\n    if (this.options.pollInterval) {\n      assertNotCacheFirstOrOnly(this);\n      queryManager.startPollingQuery(this.options, queryId);\n    }\n\n    const onError = (error: ApolloError) => {\n      // Since we don't get the current result on errors, only the error, we\n      // must mirror the updates that occur in QueryStore.markQueryError here\n      this.updateLastResult({\n        ...this.lastResult,\n        errors: error.graphQLErrors,\n        networkStatus: NetworkStatus.error,\n        loading: false,\n      });\n      iterateObserversSafely(this.observers, 'error', this.lastError = error);\n    };\n\n    queryManager.observeQuery<TData>(queryId, this.options, {\n      next: (result: ApolloQueryResult<TData>) => {\n        if (this.lastError || this.isDifferentFromLastResult(result)) {\n          const previousResult = this.updateLastResult(result);\n          const { query, variables, fetchPolicy } = this.options;\n\n          // Before calling `next` on each observer, we need to first see if\n          // the query is using `@client @export` directives, and update\n          // any variables that might have changed. If `@export` variables have\n          // changed, and the query is calling against both local and remote\n          // data, a refetch is needed to pull in new data, using the\n          // updated `@export` variables.\n          if (queryManager.transform(query).hasClientExports) {\n            queryManager.getLocalState().addExportedVariables(\n              query,\n              variables,\n            ).then((variables: TVariables) => {\n              const previousVariables = this.variables;\n              this.variables = this.options.variables = variables;\n              if (\n                !result.loading &&\n                previousResult &&\n                fetchPolicy !== 'cache-only' &&\n                queryManager.transform(query).serverQuery &&\n                !isEqual(previousVariables, variables)\n              ) {\n                this.refetch();\n              } else {\n                iterateObserversSafely(this.observers, 'next', result);\n              }\n            });\n          } else {\n            iterateObserversSafely(this.observers, 'next', result);\n          }\n        }\n      },\n      error: onError,\n    }).catch(onError);\n  }\n\n  private tearDownQuery() {\n    const { queryManager } = this;\n\n    this.isTornDown = true;\n    queryManager.stopPollingQuery(this.queryId);\n\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n    this.subscriptions.clear();\n\n    queryManager.removeObservableQuery(this.queryId);\n    queryManager.stopQuery(this.queryId);\n\n    this.observers.clear();\n  }\n}\n\nfunction defaultSubscriptionObserverErrorCallback(error: ApolloError) {\n  invariant.error('Unhandled error', error.message, error.stack);\n}\n\nfunction iterateObserversSafely<E, A>(\n  observers: Set<Observer<E>>,\n  method: keyof Observer<E>,\n  argument?: A,\n) {\n  // In case observers is modified during iteration, we need to commit to the\n  // original elements, which also provides an opportunity to filter them down\n  // to just the observers with the given method.\n  const observersWithMethod: Observer<E>[] = [];\n  observers.forEach(obs => obs[method] && observersWithMethod.push(obs));\n  observersWithMethod.forEach(obs => (obs as any)[method](argument));\n}\n\nfunction assertNotCacheFirstOrOnly<TData, TVariables>(\n  obsQuery: ObservableQuery<TData, TVariables>,\n) {\n  const { fetchPolicy } = obsQuery.options;\n  invariant(\n    fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only',\n    'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n  );\n}\n","import { DocumentNode } from 'graphql';\n\nexport class MutationStore {\n  private store: { [mutationId: string]: MutationStoreValue } = {};\n\n  public getStore(): { [mutationId: string]: MutationStoreValue } {\n    return this.store;\n  }\n\n  public get(mutationId: string): MutationStoreValue {\n    return this.store[mutationId];\n  }\n\n  public initMutation(\n    mutationId: string,\n    mutation: DocumentNode,\n    variables: Object | undefined,\n  ) {\n    this.store[mutationId] = {\n      mutation,\n      variables: variables || {},\n      loading: true,\n      error: null,\n    };\n  }\n\n  public markMutationError(mutationId: string, error: Error) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = error;\n    }\n  }\n\n  public markMutationResult(mutationId: string) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = null;\n    }\n  }\n\n  public reset() {\n    this.store = {};\n  }\n}\n\nexport interface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Object;\n  loading: boolean;\n  error: Error | null;\n}\n","import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';\nimport { isEqual } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\nimport { NetworkStatus } from '../core/networkStatus';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport type QueryStoreValue = {\n  document: DocumentNode;\n  variables: Object;\n  previousVariables?: Object | null;\n  networkStatus: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  metadata: any;\n};\n\nexport class QueryStore {\n  private store: { [queryId: string]: QueryStoreValue } = {};\n\n  public getStore(): { [queryId: string]: QueryStoreValue } {\n    return this.store;\n  }\n\n  public get(queryId: string): QueryStoreValue {\n    return this.store[queryId];\n  }\n\n  public initQuery(query: {\n    queryId: string;\n    document: DocumentNode;\n    storePreviousVariables: boolean;\n    variables: Object;\n    isPoll: boolean;\n    isRefetch: boolean;\n    metadata: any;\n    fetchMoreForQueryId: string | undefined;\n  }) {\n    const previousQuery = this.store[query.queryId];\n\n    // XXX we're throwing an error here to catch bugs where a query gets overwritten by a new one.\n    // we should implement a separate action for refetching so that QUERY_INIT may never overwrite\n    // an existing query (see also: https://github.com/apollostack/apollo-client/issues/732)\n    invariant(\n      !previousQuery ||\n      previousQuery.document === query.document ||\n      isEqual(previousQuery.document, query.document),\n      'Internal Error: may not update existing query string in store',\n    );\n\n    let isSetVariables = false;\n\n    let previousVariables: Object | null = null;\n    if (\n      query.storePreviousVariables &&\n      previousQuery &&\n      previousQuery.networkStatus !== NetworkStatus.loading\n      // if the previous query was still loading, we don't want to remember it at all.\n    ) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    // TODO break this out into a separate function\n    let networkStatus;\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n      // TODO: can we determine setVariables here if it's a refetch and the variables have changed?\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    let graphQLErrors: ReadonlyArray<GraphQLError> = [];\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    // XXX right now if QUERY_INIT is fired twice, like in a refetch situation, we just overwrite\n    // the store. We probably want a refetch action instead, because I suspect that if you refetch\n    // before the initial fetch is done, you'll get an error.\n    this.store[query.queryId] = {\n      document: query.document,\n      variables: query.variables,\n      previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus,\n      metadata: query.metadata,\n    };\n\n    // If the action had a `moreForQueryId` property then we need to set the\n    // network status on that query as well to `fetchMore`.\n    //\n    // We have a complement to this if statement in the query result and query\n    // error action branch, but importantly *not* in the client result branch.\n    // This is because the implementation of `fetchMore` *always* sets\n    // `fetchPolicy` to `network-only` so we would never have a client result.\n    if (\n      typeof query.fetchMoreForQueryId === 'string' &&\n      this.store[query.fetchMoreForQueryId]\n    ) {\n      this.store[query.fetchMoreForQueryId].networkStatus =\n        NetworkStatus.fetchMore;\n    }\n  }\n\n  public markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (\n      typeof fetchMoreForQueryId === 'string' &&\n      this.store[fetchMoreForQueryId]\n    ) {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  }\n\n  public markQueryError(\n    queryId: string,\n    error: Error,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  }\n\n  public markQueryResultClient(queryId: string, complete: boolean) {\n    const storeValue = this.store && this.store[queryId];\n    if (storeValue) {\n      storeValue.networkError = null;\n      storeValue.previousVariables = null;\n      if (complete) {\n        storeValue.networkStatus = NetworkStatus.ready;\n      }\n    }\n  }\n\n  public stopQuery(queryId: string) {\n    delete this.store[queryId];\n  }\n\n  public reset(observableQueryIds: string[]) {\n    Object.keys(this.store).forEach(queryId => {\n      if (observableQueryIds.indexOf(queryId) < 0) {\n        this.stopQuery(queryId);\n      } else {\n        // XXX set loading to true so listeners don't trigger unless they want results with partial data\n        this.store[queryId].networkStatus = NetworkStatus.loading;\n      }\n    });\n  }\n}\n","import {\n  ExecutionResult,\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n} from 'graphql';\nimport { visit, BREAK } from 'graphql/language/visitor';\n\nimport { ApolloCache } from 'apollo-cache';\nimport {\n  getMainDefinition,\n  buildQueryFromSelectionSet,\n  hasDirectives,\n  removeClientSetsFromDocument,\n  mergeDeep,\n  mergeDeepArray,\n  FragmentMap,\n  argumentsObjectFromField,\n  resultKeyNameFromField,\n  getFragmentDefinitions,\n  createFragmentMap,\n  shouldInclude,\n  isField,\n  isInlineFragment,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport ApolloClient from '../ApolloClient';\nimport { Resolvers, OperationVariables } from './types';\nimport { capitalizeFirstLetter } from '../util/capitalizeFirstLetter';\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  },\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher: FragmentMatcher;\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(resolverGroup => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: ExecutionResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<ExecutionResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers,\n      ).then(localResult => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n      invariant.warn(\n        'Found @client directives in a query but no ApolloClient resolvers ' +\n        'were specified. This means ApolloClient local resolver handling ' +\n        'has been disabled, and @client directives will be passed through ' +\n        'to your link chain.',\n      );\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return this.resolvers ? removeClientSetsFromDocument(document) : document;\n  }\n\n  public prepareContext(context = {}) {\n    const { cache } = this;\n\n    const newContext = {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: (obj: { __typename: string; id: string | number }) => {\n        if ((cache as any).config) {\n          return (cache as any).config.dataIdFromObject(obj);\n        } else {\n          invariant(false,\n            'To use context.getCacheKey, you need to use a cache that has ' +\n              'a configurable dataIdFromObject, like apollo-cache-inmemory.',\n          );\n        }\n      },\n    };\n\n    return newContext;\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables(\n    document: DocumentNode,\n    variables: OperationVariables = {},\n    context = {},\n  ) {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables,\n      ).then(data => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(\n              arg =>\n                arg.name.value === 'always' &&\n                arg.value.kind === 'BooleanValue' &&\n                arg.value.value === true,\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>,\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false,\n  ) {\n    const mainDefinition = getMainDefinition(document);\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n\n    const definitionOperation = (mainDefinition as OperationDefinitionNode)\n      .operation;\n\n    const defaultOperationType = definitionOperation\n      ? capitalizeFirstLetter(definitionOperation)\n      : 'Query';\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      onlyRunForcedResolvers,\n    };\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    ).then(result => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    rootValue: TData,\n    execContext: ExecContext,\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(selection, rootValue, execContext).then(\n          fieldResult => {\n            if (typeof fieldResult !== 'undefined') {\n              resultsToMerge.push({\n                [resultKeyNameFromField(selection)]: fieldResult,\n              } as TData);\n            }\n          },\n        );\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named ${selection.name.value}`);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            rootValue,\n            execContext,\n          ).then(fragmentResult => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function() {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    rootValue: any,\n    execContext: ExecContext,\n  ): Promise<any> {\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(resolve(\n            rootValue,\n            argumentsObjectFromField(field, variables),\n            execContext.context,\n            { field, fragmentMap: execContext.fragmentMap },\n          ));\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach(directive => {\n          if (directive.name.value === 'export' && directive.arguments) {\n            directive.arguments.forEach(arg => {\n              if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(field, result, execContext);\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          result,\n          execContext,\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    result: any[],\n    execContext: ExecContext,\n  ): any {\n    return Promise.all(\n      result.map(item => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(field, item, execContext);\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(field.selectionSet, item, execContext);\n        }\n      }),\n    );\n  }\n}\n","export function capitalizeFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n","import { Observable, Observer, Subscription } from './Observable';\n\n// Returns a normal Observable that can have any number of subscribers,\n// while ensuring the original Observable gets subscribed to at most once.\nexport function multiplex<T>(inner: Observable<T>): Observable<T> {\n  const observers = new Set<Observer<T>>();\n  let sub: Subscription | null = null;\n  return new Observable<T>(observer => {\n    observers.add(observer);\n    sub = sub || inner.subscribe({\n      next(value) {\n        observers.forEach(obs => obs.next && obs.next(value));\n      },\n      error(error) {\n        observers.forEach(obs => obs.error && obs.error(error));\n      },\n      complete() {\n        observers.forEach(obs => obs.complete && obs.complete());\n      },\n    });\n    return () => {\n      if (observers.delete(observer) && !observers.size && sub) {\n        sub.unsubscribe();\n        sub = null;\n      }\n    };\n  });\n}\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | Promise<R>,\n): Observable<R> {\n  return new Observable<R>(observer => {\n    const { next, error, complete } = observer;\n    let activeNextCount = 0;\n    let completed = false;\n\n    const handler: Observer<V> = {\n      next(value) {\n        ++activeNextCount;\n        new Promise(resolve => {\n          resolve(mapFn(value));\n        }).then(\n          result => {\n            --activeNextCount;\n            next && next.call(observer, result);\n            completed && handler.complete!();\n          },\n          e => {\n            --activeNextCount;\n            error && error.call(observer, e);\n          },\n        );\n      },\n      error(e) {\n        error && error.call(observer, e);\n      },\n      complete() {\n        completed = true;\n        if (!activeNextCount) {\n          complete && complete.call(observer);\n        }\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n","import { execute, ApolloLink, FetchResult } from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { Cache } from 'apollo-cache';\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasDirectives,\n  graphQLResultHasError,\n  hasClientExports,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n} from 'apollo-utilities';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { isApolloError, ApolloError } from '../errors/ApolloError';\nimport { Observer, Subscription, Observable } from '../util/Observable';\nimport { QueryWithUpdater, DataStore } from '../data/store';\nimport { MutationStore } from '../data/mutations';\nimport { QueryStore, QueryStoreValue } from '../data/queries';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  QueryListener,\n  ApolloQueryResult,\n  FetchType,\n  OperationVariables,\n} from './types';\nimport { LocalState } from './LocalState';\nimport { asyncMap, multiplex } from '../util/observables';\nimport { isNonEmptyArray } from '../util/arrays';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport interface QueryInfo {\n  listeners: Set<QueryListener>;\n  invalidated: boolean;\n  newData: Cache.DiffResult<any> | null;\n  document: DocumentNode | null;\n  lastRequestId: number;\n  // A map going from queryId to an observer for a query issued by watchQuery. We use\n  // these to keep track of queries that are inflight and error on the observers associated\n  // with them in case of some destabalizing action (e.g. reset of the Apollo store).\n  observableQuery: ObservableQuery<any> | null;\n  subscriptions: Set<Subscription>;\n  cancel?: () => void;\n}\n\nexport class QueryManager<TStore> {\n  public link: ApolloLink;\n  public mutationStore: MutationStore = new MutationStore();\n  public queryStore: QueryStore = new QueryStore();\n  public dataStore: DataStore<TStore>;\n  public readonly assumeImmutableResults: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast: () => void;\n\n  private ssrMode: boolean;\n\n  // let's not start at zero to avoid pain with bad checks\n  private idCounter = 1;\n\n  // XXX merge with ObservableQuery but that needs to be expanded to support mutations and\n  // subscriptions as well\n  private queries: Map<string, QueryInfo> = new Map();\n\n  // A map of Promise reject functions for fetchQuery promises that have not\n  // yet been resolved, used to keep track of in-flight queries so that we can\n  // reject them in case a destabilizing event occurs (e.g. Apollo store reset).\n  // The key is in the format of `query:${queryId}` or `fetchRequest:${queryId}`,\n  // depending on where the promise's rejection function was created from.\n  private fetchQueryRejectFns = new Map<string, Function>();\n\n  constructor({\n    link,\n    queryDeduplication = false,\n    store,\n    onBroadcast = () => undefined,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    store: DataStore<TStore>;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache: store.getCache() });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(\n        new InvariantError('QueryManager stopped while query was in flight'),\n      );\n    });\n  }\n\n  public async mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries: updateQueriesByName,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      !fetchPolicy || fetchPolicy === 'no-cache',\n      \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\"\n    );\n\n    const mutationId = this.generateQueryId();\n    mutation = this.transform(mutation).document;\n\n    this.setQuery(mutationId, () => ({ document: mutation }));\n\n    variables = this.getVariables(mutation, variables);\n\n    if (this.transform(mutation).hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context);\n    }\n\n    // Create a map of update queries by id to the query instead of by name.\n    const generateUpdateQueriesInfo: () => {\n      [queryId: string]: QueryWithUpdater;\n    } = () => {\n      const ret: { [queryId: string]: QueryWithUpdater } = {};\n\n      if (updateQueriesByName) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          if (observableQuery) {\n            const { queryName } = observableQuery;\n            if (\n              queryName &&\n              hasOwnProperty.call(updateQueriesByName, queryName)\n            ) {\n              ret[queryId] = {\n                updater: updateQueriesByName[queryName],\n                query: this.queryStore.get(queryId),\n              };\n            }\n          }\n        });\n      }\n\n      return ret;\n    };\n\n    this.mutationStore.initMutation(\n      mutationId,\n      mutation,\n      variables,\n    );\n\n    this.dataStore.markMutationInit({\n      mutationId,\n      document: mutation,\n      variables,\n      updateQueries: generateUpdateQueriesInfo(),\n      update: updateWithProxyFn,\n      optimisticResponse,\n    });\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      self.getObservableFromLink(\n        mutation,\n        {\n          ...context,\n          optimisticResponse,\n        },\n        variables,\n        false,\n      ).subscribe({\n        next(result: ExecutionResult) {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          self.mutationStore.markMutationResult(mutationId);\n\n          if (fetchPolicy !== 'no-cache') {\n            self.dataStore.markMutationResult({\n              mutationId,\n              result,\n              document: mutation,\n              variables,\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n            });\n          }\n\n          storeResult = result as FetchResult<T>;\n        },\n\n        error(err: Error) {\n          self.mutationStore.markMutationError(mutationId, err);\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n          self.broadcastQueries();\n          self.setQuery(mutationId, () => ({ document: null }));\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete() {\n          if (error) {\n            self.mutationStore.markMutationError(mutationId, error);\n          }\n\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n\n          self.broadcastQueries();\n\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          // allow for conditional refetches\n          // XXX do we want to make this the only API one day?\n          if (typeof refetchQueries === 'function') {\n            refetchQueries = refetchQueries(storeResult as ExecutionResult);\n          }\n\n          const refetchQueryPromises: Promise<\n            ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n          >[] = [];\n\n          if (isNonEmptyArray(refetchQueries)) {\n            refetchQueries.forEach(refetchQuery => {\n              if (typeof refetchQuery === 'string') {\n                self.queries.forEach(({ observableQuery }) => {\n                  if (\n                    observableQuery &&\n                    observableQuery.queryName === refetchQuery\n                  ) {\n                    refetchQueryPromises.push(observableQuery.refetch());\n                  }\n                });\n              } else {\n                const queryOptions: QueryOptions = {\n                  query: refetchQuery.query,\n                  variables: refetchQuery.variables,\n                  fetchPolicy: 'network-only',\n                };\n\n                if (refetchQuery.context) {\n                  queryOptions.context = refetchQuery.context;\n                }\n\n                refetchQueryPromises.push(self.query(queryOptions));\n              }\n            });\n          }\n\n          Promise.all(\n            awaitRefetchQueries ? refetchQueryPromises : [],\n          ).then(() => {\n            self.setQuery(mutationId, () => ({ document: null }));\n\n            if (\n              errorPolicy === 'ignore' &&\n              storeResult &&\n              graphQLResultHasError(storeResult)\n            ) {\n              delete storeResult.errors;\n            }\n\n            resolve(storeResult!);\n          });\n        },\n      });\n    });\n  }\n\n  public async fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType?: FetchType,\n    // This allows us to track if this is a query spawned by a `fetchMore`\n    // call for another query. We need this data to compute the `fetchMore`\n    // network status for the query this is fetching for.\n    fetchMoreForQueryId?: string,\n  ): Promise<FetchResult<T>> {\n    const {\n      metadata = null,\n      fetchPolicy = 'cache-first', // cache-first is the default fetch policy.\n      context = {},\n    } = options;\n\n    const query = this.transform(options.query).document;\n\n    let variables = this.getVariables(query, options.variables);\n\n    if (this.transform(query).hasClientExports) {\n      variables = await this.localState.addExportedVariables(query, variables, context);\n    }\n\n    options = { ...options, variables };\n\n    let storeResult: any;\n    const isNetworkOnly =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n    let needToFetch = isNetworkOnly;\n\n    // Unless we are completely skipping the cache, we want to diff the query\n    // against the cache before we fetch it from the network interface.\n    if (!isNetworkOnly) {\n      const { complete, result } = this.dataStore.getCache().diff({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: false,\n      });\n\n      // If we're in here, only fetch if we have missing fields\n      needToFetch = !complete || fetchPolicy === 'cache-and-network';\n      storeResult = result;\n    }\n\n    let shouldFetch =\n      needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n\n    // we need to check to see if this is an operation that uses the @live directive\n    if (hasDirectives(['live'], query)) shouldFetch = true;\n\n    const requestId = this.idCounter++;\n\n    // set up a watcher to listen to cache updates\n    const cancel = fetchPolicy !== 'no-cache'\n      ? this.updateQueryWatch(queryId, query, options)\n      : undefined;\n\n    // Initialize query in store with unique requestId\n    this.setQuery(queryId, () => ({\n      document: query,\n      lastRequestId: requestId,\n      invalidated: true,\n      cancel,\n    }));\n\n    this.invalidate(fetchMoreForQueryId);\n\n    this.queryStore.initQuery({\n      queryId,\n      document: query,\n      storePreviousVariables: shouldFetch,\n      variables,\n      isPoll: fetchType === FetchType.poll,\n      isRefetch: fetchType === FetchType.refetch,\n      metadata,\n      fetchMoreForQueryId,\n    });\n\n    this.broadcastQueries();\n\n    if (shouldFetch) {\n      const networkResult = this.fetchRequest<T>({\n        requestId,\n        queryId,\n        document: query,\n        options,\n        fetchMoreForQueryId,\n      }).catch(error => {\n        // This is for the benefit of `refetch` promises, which currently don't get their errors\n        // through the store like watchQuery observers do\n        if (isApolloError(error)) {\n          throw error;\n        } else {\n          if (requestId >= this.getQuery(queryId).lastRequestId) {\n            this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n            this.invalidate(queryId);\n            this.invalidate(fetchMoreForQueryId);\n            this.broadcastQueries();\n          }\n          throw new ApolloError({ networkError: error });\n        }\n      });\n\n      // we don't return the promise for cache-and-network since it is already\n      // returned below from the cache\n      if (fetchPolicy !== 'cache-and-network') {\n        return networkResult;\n      }\n\n      // however we need to catch the error so it isn't unhandled in case of\n      // network error\n      networkResult.catch(() => {});\n    }\n\n    // If there is no part of the query we need to fetch from the server (or,\n    // fetchPolicy is cache-only), we just write the store result as the final result.\n    this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n    this.invalidate(queryId);\n    this.invalidate(fetchMoreForQueryId);\n\n    if (this.transform(query).hasForcedResolvers) {\n      return this.localState.runResolvers({\n        document: query,\n        remoteResult: { data: storeResult },\n        context,\n        variables,\n        onlyRunForcedResolvers: true,\n      }).then((result: FetchResult<T>) => {\n        this.markQueryResult(\n          queryId,\n          result,\n          options,\n          fetchMoreForQueryId,\n        );\n        this.broadcastQueries();\n        return result;\n      });\n    }\n\n    this.broadcastQueries();\n\n    // If we have no query to send to the server, we should return the result\n    // found within the store.\n    return { data: storeResult };\n  }\n\n  private markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    {\n      fetchPolicy,\n      variables,\n      errorPolicy,\n    }: WatchQueryOptions,\n    fetchMoreForQueryId?: string,\n  ) {\n    if (fetchPolicy === 'no-cache') {\n      this.setQuery(queryId, () => ({\n        newData: { result: result.data, complete: true },\n      }));\n    } else {\n      this.dataStore.markQueryResult(\n        result,\n        this.getQuery(queryId).document!,\n        variables,\n        fetchMoreForQueryId,\n        errorPolicy === 'ignore' || errorPolicy === 'all',\n      );\n    }\n  }\n\n  // Returns a query listener that will update the given observer based on the\n  // results (or lack thereof) for a particular query.\n  public queryListenerForObserver<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ): QueryListener {\n    function invoke(method: 'next' | 'error', argument: any) {\n      if (observer[method]) {\n        try {\n          observer[method]!(argument);\n        } catch (e) {\n          invariant.error(e);\n        }\n      } else if (method === 'error') {\n        invariant.error(argument);\n      }\n    }\n\n    return (\n      queryStoreValue: QueryStoreValue,\n      newData?: Cache.DiffResult<T>,\n    ) => {\n      // we're going to take a look at the data, so the query is no longer invalidated\n      this.invalidate(queryId, false);\n\n      // The query store value can be undefined in the event of a store\n      // reset.\n      if (!queryStoreValue) return;\n\n      const { observableQuery, document } = this.getQuery(queryId);\n\n      const fetchPolicy = observableQuery\n        ? observableQuery.options.fetchPolicy\n        : options.fetchPolicy;\n\n      // don't watch the store for queries on standby\n      if (fetchPolicy === 'standby') return;\n\n      const loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);\n      const lastResult = observableQuery && observableQuery.getLastResult();\n\n      const networkStatusChanged = !!(\n        lastResult &&\n        lastResult.networkStatus !== queryStoreValue.networkStatus\n      );\n\n      const shouldNotifyIfLoading =\n        options.returnPartialData ||\n        (!newData && queryStoreValue.previousVariables) ||\n        (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n        fetchPolicy === 'cache-only' ||\n        fetchPolicy === 'cache-and-network';\n\n      if (loading && !shouldNotifyIfLoading) {\n        return;\n      }\n\n      const hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);\n\n      const errorPolicy: ErrorPolicy = observableQuery\n        && observableQuery.options.errorPolicy\n        || options.errorPolicy\n        || 'none';\n\n      // If we have either a GraphQL error or a network error, we create\n      // an error and tell the observer about it.\n      if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {\n        return invoke('error', new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError,\n        }));\n      }\n\n      try {\n        let data: any;\n        let isMissing: boolean;\n\n        if (newData) {\n          // As long as we're using the cache, clear out the latest\n          // `newData`, since it will now become the current data. We need\n          // to keep the `newData` stored with the query when using\n          // `no-cache` since `getCurrentQueryResult` attemps to pull from\n          // `newData` first, following by trying the cache (which won't\n          // find a hit for `no-cache`).\n          if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {\n            this.setQuery(queryId, () => ({ newData: null }));\n          }\n\n          data = newData.result;\n          isMissing = !newData.complete;\n        } else {\n          const lastError = observableQuery && observableQuery.getLastError();\n          const errorStatusChanged =\n            errorPolicy !== 'none' &&\n            (lastError && lastError.graphQLErrors) !==\n              queryStoreValue.graphQLErrors;\n\n          if (lastResult && lastResult.data && !errorStatusChanged) {\n            data = lastResult.data;\n            isMissing = false;\n          } else {\n            const diffResult = this.dataStore.getCache().diff({\n              query: document as DocumentNode,\n              variables:\n                queryStoreValue.previousVariables ||\n                queryStoreValue.variables,\n              returnPartialData: true,\n              optimistic: true,\n            });\n\n            data = diffResult.result;\n            isMissing = !diffResult.complete;\n          }\n        }\n\n        // If there is some data missing and the user has told us that they\n        // do not tolerate partial data then we want to return the previous\n        // result and mark it as stale.\n        const stale = isMissing && !(\n          options.returnPartialData ||\n          fetchPolicy === 'cache-only'\n        );\n\n        const resultFromStore: ApolloQueryResult<T> = {\n          data: stale ? lastResult && lastResult.data : data,\n          loading,\n          networkStatus: queryStoreValue.networkStatus,\n          stale,\n        };\n\n        // if the query wants updates on errors we need to add it to the result\n        if (errorPolicy === 'all' && hasGraphQLErrors) {\n          resultFromStore.errors = queryStoreValue.graphQLErrors;\n        }\n\n        invoke('next', resultFromStore);\n\n      } catch (networkError) {\n        invoke('error', new ApolloError({ networkError }));\n      }\n    };\n  }\n\n  private transformCache = new (canUseWeakMap ? WeakMap : Map)<\n    DocumentNode,\n    Readonly<{\n      document: Readonly<DocumentNode>;\n      hasClientExports: boolean;\n      hasForcedResolvers: boolean;\n      clientQuery: Readonly<DocumentNode> | null;\n      serverQuery: Readonly<DocumentNode> | null;\n      defaultVars: Readonly<OperationVariables>;\n    }>\n  >();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cache = this.dataStore.getCache();\n      const transformed = cache.transformDocument(document);\n      const forLink = removeConnectionDirectiveFromDocument(\n        cache.transformForLink(transformed));\n\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = this.localState.serverQuery(forLink);\n\n      const cacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables(\n    document: DocumentNode,\n    variables?: OperationVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  // The shouldSubscribe option is a temporary fix that tells us whether watchQuery was called\n  // directly (i.e. through ApolloClient) or through the query method within QueryManager.\n  // Currently, the query method uses watchQuery in order to handle non-network errors correctly\n  // but we don't want to keep track observables issued for the query method since those aren't\n  // supposed to be refetched in the event of a store reset. Once we unify error handling for\n  // network errors and non-network errors, the shouldSubscribe option will go away.\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions,\n    shouldSubscribe = true,\n  ): ObservableQuery<T, TVariables> {\n    invariant(\n      options.fetchPolicy !== 'standby',\n      'client.watchQuery cannot be called with fetchPolicy set to \"standby\"',\n    );\n\n    // assign variable default values if supplied\n    options.variables = this.getVariables(options.query, options.variables);\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    let transformedOptions = { ...options } as WatchQueryOptions<TVariables>;\n\n    return new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe,\n    });\n  }\n\n  public query<T>(options: QueryOptions): Promise<ApolloQueryResult<T>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const watchedQuery = this.watchQuery<T>(options, false);\n      this.fetchQueryRejectFns.set(`query:${watchedQuery.queryId}`, reject);\n      watchedQuery\n        .result()\n        .then(resolve, reject)\n        // Since neither resolve nor reject throw or return a value, this .then\n        // handler is guaranteed to execute. Note that it doesn't really matter\n        // when we remove the reject function from this.fetchQueryRejectFns,\n        // since resolve and reject are mutually idempotent. In fact, it would\n        // not be incorrect to let reject functions accumulate over time; it's\n        // just a waste of memory.\n        .then(() =>\n          this.fetchQueryRejectFns.delete(`query:${watchedQuery.queryId}`),\n        );\n    });\n  }\n\n  public generateQueryId() {\n    return String(this.idCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    this.stopPollingQuery(queryId);\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(queryId);\n  }\n\n  public addQueryListener(queryId: string, listener: QueryListener) {\n    this.setQuery(queryId, ({ listeners }) => {\n      listeners.add(listener);\n      return { invalidated: false };\n    });\n  }\n\n  public updateQueryWatch(\n    queryId: string,\n    document: DocumentNode,\n    options: WatchQueryOptions,\n  ) {\n    const { cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    const previousResult = () => {\n      let previousResult = null;\n      const { observableQuery } = this.getQuery(queryId);\n      if (observableQuery) {\n        const lastResult = observableQuery.getLastResult();\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n    return this.dataStore.getCache().watch({\n      query: document as DocumentNode,\n      variables: options.variables,\n      optimistic: true,\n      previousResult,\n      callback: newData => {\n        this.setQuery(queryId, () => ({ invalidated: true, newData }));\n      },\n    });\n  }\n\n  // Adds an ObservableQuery to this.observableQueries and to this.observableQueriesByName.\n  public addObservableQuery<T>(\n    queryId: string,\n    observableQuery: ObservableQuery<T>,\n  ) {\n    this.setQuery(queryId, () => ({ observableQuery }));\n  }\n\n  public removeObservableQuery(queryId: string) {\n    const { cancel } = this.getQuery(queryId);\n    this.setQuery(queryId, () => ({ observableQuery: null }));\n    if (cancel) cancel();\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store,\n    // we can no longer rely on the results returned by in-flight\n    // requests since these may depend on values that previously existed\n    // in the data portion of the store. So, we cancel the promises and observers\n    // that we have issued so far and not yet resolved (in the case of\n    // queries).\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(new InvariantError(\n        'Store reset while query was in flight (not completed in link chain)',\n      ));\n    });\n\n    const resetIds: string[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) resetIds.push(queryId);\n    });\n\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n\n    // begin removing data from the store\n    return this.dataStore.reset();\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) {\n        const fetchPolicy = observableQuery.options.fetchPolicy;\n\n        observableQuery.resetLastResults();\n        if (\n          fetchPolicy !== 'cache-only' &&\n          (includeStandby || fetchPolicy !== 'standby')\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n\n        this.setQuery(queryId, () => ({ newData: null }));\n        this.invalidate(queryId);\n      }\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public observeQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ) {\n    this.addQueryListener(\n      queryId,\n      this.queryListenerForObserver(queryId, options, observer),\n    );\n    return this.fetchQuery<T>(queryId, options);\n  }\n\n  public startQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    listener: QueryListener,\n  ) {\n    invariant.warn(\"The QueryManager.startQuery method has been deprecated\");\n\n    this.addQueryListener(queryId, listener);\n\n    this.fetchQuery<T>(queryId, options)\n      // `fetchQuery` returns a Promise. In case of a failure it should be caucht or else the\n      // console will show an `Uncaught (in promise)` message. Ignore the error for now.\n      .catch(() => undefined);\n\n    return queryId;\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    variables,\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        {},\n        variables,\n        false,\n      ).map(result => {\n        if (!fetchPolicy || fetchPolicy !== 'no-cache') {\n          this.dataStore.markSubscriptionResult(\n            result,\n            query,\n            variables,\n          );\n          this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors,\n          });\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: Subscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchQueryRejectFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchQueryRejectFns.delete(`query:${queryId}`);\n    this.fetchQueryRejectFns.delete(`fetchRequest:${queryId}`);\n    this.getQuery(queryId).subscriptions.forEach(x => x.unsubscribe());\n    this.queries.delete(queryId);\n  }\n\n  public getCurrentQueryResult<T>(\n    observableQuery: ObservableQuery<T>,\n    optimistic: boolean = true,\n  ): {\n    data: T | undefined;\n    partial: boolean;\n  } {\n    const { variables, query, fetchPolicy, returnPartialData } = observableQuery.options;\n    const lastResult = observableQuery.getLastResult();\n    const { newData } = this.getQuery(observableQuery.queryId);\n\n    if (newData && newData.complete) {\n      return { data: newData.result, partial: false };\n    }\n\n    if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {\n      return { data: undefined, partial: false };\n    }\n\n    const { result, complete } = this.dataStore.getCache().diff<T>({\n      query,\n      variables,\n      previousResult: lastResult ? lastResult.data : undefined,\n      returnPartialData: true,\n      optimistic,\n    });\n\n    return {\n      data: (complete || returnPartialData) ? result : void 0,\n      partial: !complete,\n    };\n  }\n\n  public getQueryWithPreviousResult<TData, TVariables = OperationVariables>(\n    queryIdOrObservable: string | ObservableQuery<TData, TVariables>,\n  ): {\n    previousResult: any;\n    variables: TVariables | undefined;\n    document: DocumentNode;\n  } {\n    let observableQuery: ObservableQuery<TData, any>;\n    if (typeof queryIdOrObservable === 'string') {\n      const { observableQuery: foundObserveableQuery } = this.getQuery(\n        queryIdOrObservable,\n      );\n      invariant(\n        foundObserveableQuery,\n        `ObservableQuery with this id doesn't exist: ${queryIdOrObservable}`\n      );\n      observableQuery = foundObserveableQuery!;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    const { variables, query } = observableQuery.options;\n    return {\n      previousResult: this.getCurrentQueryResult(observableQuery, false).data,\n      variables,\n      document: query,\n    };\n  }\n\n  public broadcastQueries() {\n    this.onBroadcast();\n    this.queries.forEach((info, id) => {\n      if (info.invalidated) {\n        info.listeners.forEach(listener => {\n          // it's possible for the listener to be undefined if the query is being stopped\n          // See here for more detail: https://github.com/apollostack/apollo-client/issues/231\n          if (listener) {\n            listener(this.queryStore.get(id), info.newData);\n          }\n        });\n      }\n    });\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean = this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = JSON.stringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          byVariables.set(\n            varJson,\n            observable = multiplex(\n              execute(link, operation) as Observable<FetchResult<T>>\n            )\n          );\n\n          const cleanup = () => {\n            byVariables.delete(varJson);\n            if (!byVariables.size) inFlightLinkObservables.delete(serverQuery);\n            cleanupSub.unsubscribe();\n          };\n\n          const cleanupSub = observable.subscribe({\n            next: cleanup,\n            error: cleanup,\n            complete: cleanup,\n          });\n        }\n\n      } else {\n        observable = multiplex(execute(link, operation) as Observable<FetchResult<T>>);\n      }\n    } else {\n      observable = Observable.of({ data: {} } as FetchResult<T>);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  // Takes a request id, query id, a query document and information associated with the query\n  // and send it to the network interface. Returns\n  // a promise for the result associated with that request.\n  private fetchRequest<T>({\n    requestId,\n    queryId,\n    document,\n    options,\n    fetchMoreForQueryId,\n  }: {\n    requestId: number;\n    queryId: string;\n    document: DocumentNode;\n    options: WatchQueryOptions;\n    fetchMoreForQueryId?: string;\n  }): Promise<FetchResult<T>> {\n    const { variables, errorPolicy = 'none', fetchPolicy } = options;\n    let resultFromStore: any;\n    let errorsFromStore: any;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const observable = this.getObservableFromLink(\n        document,\n        options.context,\n        variables,\n      );\n\n      const fqrfId = `fetchRequest:${queryId}`;\n      this.fetchQueryRejectFns.set(fqrfId, reject);\n\n      const cleanup = () => {\n        this.fetchQueryRejectFns.delete(fqrfId);\n        this.setQuery(queryId, ({ subscriptions }) => {\n          subscriptions.delete(subscription);\n        });\n      };\n\n      const subscription = observable.map((result: ExecutionResult) => {\n        if (requestId >= this.getQuery(queryId).lastRequestId) {\n          this.markQueryResult(\n            queryId,\n            result,\n            options,\n            fetchMoreForQueryId,\n          );\n\n          this.queryStore.markQueryResult(\n            queryId,\n            result,\n            fetchMoreForQueryId,\n          );\n\n          this.invalidate(queryId);\n          this.invalidate(fetchMoreForQueryId);\n\n          this.broadcastQueries();\n        }\n\n        if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {\n          return reject(new ApolloError({\n            graphQLErrors: result.errors,\n          }));\n        }\n\n        if (errorPolicy === 'all') {\n          errorsFromStore = result.errors;\n        }\n\n        if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n          // We don't write fetchMore results to the store because this would overwrite\n          // the original result in case an @connection directive is used.\n          resultFromStore = result.data;\n        } else {\n          // ensure result is combined with data already in store\n          const { result, complete } = this.dataStore.getCache().diff<T>({\n            variables,\n            query: document,\n            optimistic: false,\n            returnPartialData: true,\n          });\n\n          if (complete || options.returnPartialData) {\n            resultFromStore = result;\n          }\n        }\n      }).subscribe({\n        error(error: ApolloError) {\n          cleanup();\n          reject(error);\n        },\n\n        complete() {\n          cleanup();\n          resolve({\n            data: resultFromStore,\n            errors: errorsFromStore,\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            stale: false,\n          });\n        },\n      });\n\n      this.setQuery(queryId, ({ subscriptions }) => {\n        subscriptions.add(subscription);\n      });\n    });\n  }\n\n  private getQuery(queryId: string) {\n    return (\n      this.queries.get(queryId) || {\n        listeners: new Set<QueryListener>(),\n        invalidated: false,\n        document: null,\n        newData: null,\n        lastRequestId: 1,\n        observableQuery: null,\n        subscriptions: new Set<Subscription>(),\n      }\n    );\n  }\n\n  private setQuery<T extends keyof QueryInfo>(\n    queryId: string,\n    updater: (prev: QueryInfo) => Pick<QueryInfo, T> | void,\n  ) {\n    const prev = this.getQuery(queryId);\n    const newInfo = { ...prev, ...updater(prev) };\n    this.queries.set(queryId, newInfo);\n  }\n\n  private invalidate(\n    queryId: string | undefined,\n    invalidated = true,\n  ) {\n    if (queryId) {\n      this.setQuery(queryId, () => ({ invalidated }));\n    }\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n\n  public checkInFlight(queryId: string) {\n    const query = this.queryStore.get(queryId);\n\n    return (\n      query &&\n      query.networkStatus !== NetworkStatus.ready &&\n      query.networkStatus !== NetworkStatus.error\n    );\n  }\n\n  // Map from client ID to { interval, options }.\n  private pollingInfoByQueryId = new Map<string, {\n    interval: number;\n    timeout: NodeJS.Timeout;\n    options: WatchQueryOptions;\n  }>();\n\n  public startPollingQuery(\n    options: WatchQueryOptions,\n    queryId: string,\n    listener?: QueryListener,\n  ): string {\n    const { pollInterval } = options;\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Do not poll in SSR mode\n    if (!this.ssrMode) {\n      let info = this.pollingInfoByQueryId.get(queryId)!;\n      if (!info) {\n        this.pollingInfoByQueryId.set(queryId, (info = {} as any));\n      }\n\n      info.interval = pollInterval!;\n      info.options = {\n        ...options,\n        fetchPolicy: 'network-only',\n      };\n\n      const maybeFetch = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          if (this.checkInFlight(queryId)) {\n            poll();\n          } else {\n            this.fetchQuery(queryId, info.options, FetchType.poll).then(\n              poll,\n              poll,\n            );\n          }\n        }\n      };\n\n      const poll = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          clearTimeout(info.timeout);\n          info.timeout = setTimeout(maybeFetch, info.interval);\n        }\n      };\n\n      if (listener) {\n        this.addQueryListener(queryId, listener);\n      }\n\n      poll();\n    }\n\n    return queryId;\n  }\n\n  public stopPollingQuery(queryId: string) {\n    this.pollingInfoByQueryId.delete(queryId);\n  }\n}\n","import { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, Cache, DataProxy } from 'apollo-cache';\n\nimport { QueryStoreValue } from '../data/queries';\nimport {\n  getOperationName,\n  tryFunctionOrLogError,\n  graphQLResultHasError,\n} from 'apollo-utilities';\nimport { MutationQueryReducer } from '../core/types';\n\nexport type QueryWithUpdater = {\n  updater: MutationQueryReducer<Object>;\n  query: QueryStoreValue;\n};\n\nexport interface DataWrite {\n  rootId: string;\n  result: any;\n  document: DocumentNode;\n  operationName: string | null;\n  variables: Object;\n}\n\nexport class DataStore<TSerialized> {\n  private cache: ApolloCache<TSerialized>;\n\n  constructor(initialCache: ApolloCache<TSerialized>) {\n    this.cache = initialCache;\n  }\n\n  public getCache(): ApolloCache<TSerialized> {\n    return this.cache;\n  }\n\n  public markQueryResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n    fetchMoreForQueryId: string | undefined,\n    ignoreErrors: boolean = false,\n  ) {\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markSubscriptionResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n  ) {\n    // the subscription interface should handle not sending us results we no longer subscribe to.\n    // XXX I don't think we ever send in an object with errors, but we might in the future...\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markMutationInit(mutation: {\n    mutationId: string;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n    optimisticResponse: Object | Function | undefined;\n  }) {\n    if (mutation.optimisticResponse) {\n      let optimistic: Object;\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic = mutation.optimisticResponse;\n      }\n\n      this.cache.recordOptimisticTransaction(c => {\n        const orig = this.cache;\n        this.cache = c;\n\n        try {\n          this.markMutationResult({\n            mutationId: mutation.mutationId,\n            result: { data: optimistic },\n            document: mutation.document,\n            variables: mutation.variables,\n            updateQueries: mutation.updateQueries,\n            update: mutation.update,\n          });\n        } finally {\n          this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  }\n\n  public markMutationResult(mutation: {\n    mutationId: string;\n    result: ExecutionResult;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n  }) {\n    // Incorporate the result from this mutation into the store\n    if (!graphQLResultHasError(mutation.result)) {\n      const cacheWrites: Cache.WriteOptions[] = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      }];\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        Object.keys(updateQueries).forEach(id => {\n          const { query, updater } = updateQueries[id];\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = this.cache.diff({\n            query: query.document,\n            variables: query.variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = tryFunctionOrLogError(() =>\n              updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables,\n              }),\n            );\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables,\n              });\n            }\n          }\n        });\n      }\n\n      this.cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n\n        // If the mutation has some writes associated with it then we need to\n        // apply those writes to the store by running this reducer again with a\n        // write action.\n        const { update } = mutation;\n        if (update) {\n          tryFunctionOrLogError(() => update(c, mutation.result));\n        }\n      });\n    }\n  }\n\n  public markMutationComplete({\n    mutationId,\n    optimisticResponse,\n  }: {\n    mutationId: string;\n    optimisticResponse?: any;\n  }) {\n    if (optimisticResponse) {\n      this.cache.removeOptimistic(mutationId);\n    }\n  }\n\n  public markUpdateQueryResult(\n    document: DocumentNode,\n    variables: any,\n    newResult: any,\n  ) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables,\n      query: document,\n    });\n  }\n\n  public reset(): Promise<void> {\n    return this.cache.reset();\n  }\n}\n","export const version = \"2.6.8\"","import {\n  ApolloLink,\n  FetchResult,\n  GraphQLRequest,\n  execute,\n} from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, DataProxy } from 'apollo-cache';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { QueryManager } from './core/QueryManager';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  Resolvers,\n} from './core/types';\nimport { ObservableQuery } from './core/ObservableQuery';\nimport { LocalState, FragmentMatcher } from './core/LocalState';\nimport { Observable } from './util/Observable';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  WatchQueryFetchPolicy,\n} from './core/watchQueryOptions';\n\nimport { DataStore } from './data/store';\n\nimport { version } from './version';\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions>;\n  query?: Partial<QueryOptions>;\n  mutate?: Partial<MutationOptions>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n};\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport default class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public store: DataStore<TCacheShape>;\n  public cache: ApolloCache<TCacheShape>;\n  public readonly queryManager: QueryManager<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\n\n  private devToolsHookCb: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param assumeImmutableResults When this option is true, the client will assume results\n   *                               read from the cache are never mutated by application code,\n   *                               which enables substantial performance optimizations. Passing\n   *                               `{ freezeResults: true }` to the `InMemoryCache` constructor\n   *                               can help enforce this immutability.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = false,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    // If a link hasn't been defined, but local state resolvers have been set,\n    // setup a default empty link.\n    if (!link && resolvers) {\n      link = ApolloLink.empty();\n    }\n\n    if (!link || !cache) {\n      throw new InvariantError(\n        \"In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\\n\" +\n        \"These options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\\n\" +\n        \"For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup\"\n      );\n    }\n\n    // remove apollo-client supported directives\n    this.link = link;\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    // Attach the client instance to window to let us be found by chrome devtools, but only in\n    // development mode\n    const defaultConnectToDevTools =\n      process.env.NODE_ENV !== 'production' &&\n      typeof window !== 'undefined' &&\n      !(window as any).__APOLLO_CLIENT__;\n\n    if (\n      typeof connectToDevTools === 'undefined'\n        ? defaultConnectToDevTools\n        : connectToDevTools && typeof window !== 'undefined'\n    ) {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self\n      ) {\n        // First check if devtools is not installed\n        if (\n          typeof (window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined'\n        ) {\n          // Only for Chrome\n          if (\n            window.navigator &&\n            window.navigator.userAgent &&\n            window.navigator.userAgent.indexOf('Chrome') > -1\n          ) {\n            // tslint:disable-next-line\n            console.debug(\n              'Download the Apollo DevTools ' +\n                'for a better development experience: ' +\n                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm',\n            );\n          }\n        }\n      }\n    }\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      link: this.link,\n      store: this.store,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast: () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: this.queryManager.queryStore.getStore(),\n              mutations: this.queryManager.mutationStore.getStore(),\n            },\n            dataWithOptimisticResults: this.cache.extract(true),\n          });\n        }\n      },\n    });\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T = any, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables>,\n  ): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = {\n        ...this.defaultOptions.watchQuery,\n        ...options,\n      } as WatchQueryOptions<TVariables>;\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T = any, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = { ...this.defaultOptions.query, ...options } as QueryOptions<\n        TVariables\n      >;\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== 'cache-and-network',\n      'The cache-and-network fetchPolicy does not work with client.query, because ' +\n      'client.query can only return a single result. Please use client.watchQuery ' +\n      'to receive multiple results from the cache and the network, or consider ' +\n      'using a different fetchPolicy, such as cache-first or network-only.'\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.query<T>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T = any, TVariables = OperationVariables>(\n    options: MutationOptions<T, TVariables>,\n  ): Promise<FetchResult<T>> {\n    if (this.defaultOptions.mutate) {\n      options = {\n        ...this.defaultOptions.mutate,\n        ...options,\n      } as MutationOptions<T, TVariables>;\n    }\n\n    return this.queryManager.mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables>,\n  ): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeQuery<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeFragment<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Sugar for writeQuery & writeFragment\n   * This method will construct a query from the data object passed in.\n   * If no id is supplied, writeData will write the data to the root.\n   * If an id is supplied, writeData will write a fragment to the object\n   * specified by the id in the store.\n   *\n   * Since you aren't passing in a query to check the shape of the data,\n   * you must pass in an object that conforms to the shape of valid GraphQL data.\n   */\n  public writeData<TData = any>(\n    options: DataProxy.WriteDataOptions<TData>,\n  ): void {\n    const result = this.cache.writeData<TData>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * This initializes the query manager that tracks queries and the cache\n   */\n  public initQueryManager(): QueryManager<TCacheShape> {\n    invariant.warn(\n      'Calling the initQueryManager method is no longer necessary, ' +\n        'and it will be removed from ApolloClient in version 3.0.',\n    );\n    return this.queryManager;\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n}\n","/* tslint:disable */\n\nimport zenObservable from 'zen-observable';\n\nnamespace Observable {\n\n}\n\nimport { ZenObservable } from './types';\n\nexport { ZenObservable };\n\nexport type Observer<T> = ZenObservable.Observer<T>;\nexport type Subscriber<T> = ZenObservable.Subscriber<T>;\nexport type ObservableLike<T> = ZenObservable.ObservableLike<T>;\n\nexport const Observable: {\n  new <T>(subscriber: Subscriber<T>): Observable<T>;\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n} = <any>zenObservable;\n\nexport interface Observable<T> {\n  subscribe(\n    observerOrNext: ((value: T) => void) | ZenObservable.Observer<T>,\n    error?: (error: any) => void,\n    complete?: () => void,\n  ): ZenObservable.Subscription;\n\n  forEach(fn: (value: T) => void): Promise<void>;\n\n  map<R>(fn: (value: T) => R): Observable<R>;\n\n  filter(fn: (value: T) => boolean): Observable<T>;\n\n  reduce<R = T>(\n    fn: (previousValue: R | T, currentValue: T) => R | T,\n    initialValue?: R | T,\n  ): Observable<R | T>;\n\n  flatMap<R>(fn: (value: T) => ZenObservable.ObservableLike<R>): Observable<R>;\n\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n}\n","const { toString, hasOwnProperty } = Object.prototype;\nconst previousComparisons = new Map<object, Set<object>>();\n\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */\nexport function equal(a: any, b: any): boolean {\n  try {\n    return check(a, b);\n  } finally {\n    previousComparisons.clear();\n  }\n}\n\n// Allow default imports as well.\nexport default equal;\n\nfunction check(a: any, b: any): boolean {\n  // If the two values are strictly equal, our job is easy.\n  if (a === b) {\n    return true;\n  }\n\n  // Object.prototype.toString returns a representation of the runtime type of\n  // the given value that is considerably more precise than typeof.\n  const aTag = toString.call(a);\n  const bTag = toString.call(b);\n\n  // If the runtime types of a and b are different, they could maybe be equal\n  // under some interpretation of equality, but for simplicity and performance\n  // we just return false instead.\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case '[object Array]':\n      // Arrays are a lot like other objects, but we can cheaply compare their\n      // lengths as a short-cut before comparing their elements.\n      if (a.length !== b.length) return false;\n      // Fall through to object case...\n    case '[object Object]': {\n      if (previouslyCompared(a, b)) return true;\n\n      const aKeys = Object.keys(a);\n      const bKeys = Object.keys(b);\n\n      // If `a` and `b` have a different number of enumerable keys, they\n      // must be different.\n      const keyCount = aKeys.length;\n      if (keyCount !== bKeys.length) return false;\n\n      // Now make sure they have the same keys.\n      for (let k = 0; k < keyCount; ++k) {\n        if (!hasOwnProperty.call(b, aKeys[k])) {\n          return false;\n        }\n      }\n\n      // Finally, check deep equality of all child properties.\n      for (let k = 0; k < keyCount; ++k) {\n        const key = aKeys[k];\n        if (!check(a[key], b[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    case '[object Error]':\n      return a.name === b.name && a.message === b.message;\n\n    case '[object Number]':\n      // Handle NaN, which is !== itself.\n      if (a !== a) return b !== b;\n      // Fall through to shared +a === +b case...\n    case '[object Boolean]':\n    case '[object Date]':\n      return +a === +b;\n\n    case '[object RegExp]':\n    case '[object String]':\n      return a == `${b}`;\n\n    case '[object Map]':\n    case '[object Set]': {\n      if (a.size !== b.size) return false;\n      if (previouslyCompared(a, b)) return true;\n\n      const aIterator = a.entries();\n      const isMap = aTag === '[object Map]';\n\n      while (true) {\n        const info = aIterator.next();\n        if (info.done) break;\n\n        // If a instanceof Set, aValue === aKey.\n        const [aKey, aValue] = info.value;\n\n        // So this works the same way for both Set and Map.\n        if (!b.has(aKey)) {\n          return false;\n        }\n\n        // However, we care about deep equality of values only when dealing\n        // with Map structures.\n        if (isMap && !check(aValue, b.get(aKey))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  // Otherwise the values are not equal.\n  return false;\n}\n\nfunction previouslyCompared(a: object, b: object): boolean {\n  // Though cyclic references can make an object graph appear infinite from the\n  // perspective of a depth-first traversal, the graph still contains a finite\n  // number of distinct object references. We use the previousComparisons cache\n  // to avoid comparing the same pair of object references more than once, which\n  // guarantees termination (even if we end up comparing every object in one\n  // graph to every object in the other graph, which is extremely unlikely),\n  // while still allowing weird isomorphic structures (like rings with different\n  // lengths) a chance to pass the equality test.\n  let bSet = previousComparisons.get(a);\n  if (bSet) {\n    // Return true here because we can be sure false will be returned somewhere\n    // else if the objects are not equivalent.\n    if (bSet.has(b)) return true;\n  } else {\n    previousComparisons.set(a, bSet = new Set);\n  }\n  bSet.add(b);\n  return false;\n}\n","import inspect from '../jsutils/inspect';\nexport var QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nexport var BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nexport function visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {\n            var k = _Object$keys2[_i2];\n            clone[k] = node[k];\n          }\n\n          node = clone;\n        }\n\n        var editOffset = 0;\n\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + inspect(node));\n      }\n\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\n\nexport function visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          false);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          true);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n\n      var specificKindVisitor = specificVisitor[kind];\n\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}\n","import isPlainObject from 'lodash/isPlainObject';\nexport function objToKey(obj) {\n  if (!isPlainObject(obj)) {\n    return obj;\n  }\n\n  var sortedObj = Object.keys(obj).sort().reduce(function (result, key) {\n    result[key] = objToKey(obj[key]);\n    return result;\n  }, {});\n  return JSON.stringify(sortedObj);\n}\nexport function isPromiseLike(value) {\n  return value != null && typeof value.then === 'function';\n}\nexport function compact(obj) {\n  return Object.keys(obj).reduce(function (acc, key) {\n    if (obj[key] !== undefined) {\n      acc[key] = obj[key];\n    }\n\n    return acc;\n  }, {});\n}","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport nodejsCustomInspectSymbol from './nodejsCustomInspectSymbol';\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nexport default function inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (_typeof(value)) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? \"[function \".concat(value.name, \"]\") : '[function]';\n\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  var seenValues = [].concat(previouslySeenValues, [value]);\n  var customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    // $FlowFixMe(>=0.90.0)\n    var customValue = customInspectFn.call(value); // check for infinite recursion\n\n    if (customValue !== value) {\n      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object, seenValues) {\n  var keys = Object.keys(object);\n\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  var properties = keys.map(function (key) {\n    var value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  var remaining = array.length - len;\n  var items = [];\n\n  for (var i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(\"... \".concat(remaining, \" more items\"));\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(object) {\n  var customInspectFn = object[String(nodejsCustomInspectSymbol)];\n\n  if (typeof customInspectFn === 'function') {\n    return customInspectFn;\n  }\n\n  if (typeof object.inspect === 'function') {\n    return object.inspect;\n  }\n}\n\nfunction getObjectTag(object) {\n  var tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    var name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n","var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;\nexport default nodejsCustomInspectSymbol;\n","/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n} // @internal\n\nexport function getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nexport function printBlockString(value) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isSingleLine = value.indexOf('\\n') === -1;\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\n  var hasTrailingQuote = value[value.length - 1] === '\"';\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n' + indentation;\n  }\n\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n","import Observable from 'zen-observable-ts';\n\nimport { GraphQLRequest, Operation } from './types';\nimport { ApolloLink } from './link';\n\nimport { getOperationName } from 'apollo-utilities';\nimport { invariant, InvariantError } from 'ts-invariant';\nexport { getOperationName };\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    'query',\n    'operationName',\n    'variables',\n    'extensions',\n    'context',\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw new InvariantError(`illegal argument: ${key}`);\n    }\n  }\n\n  return operation;\n}\n\nexport class LinkError extends Error {\n  public link: ApolloLink;\n  constructor(message?: string, link?: ApolloLink) {\n    super(message);\n    this.link = link;\n  }\n}\n\nexport function isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport function toPromise<R>(observable: Observable<R>): Promise<R> {\n  let completed = false;\n  return new Promise<R>((resolve, reject) => {\n    observable.subscribe({\n      next: data => {\n        if (completed) {\n          invariant.warn(\n            `Promise Wrapper does not support multiple results from Observable`,\n          );\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject,\n    });\n  });\n}\n\n// backwards compat\nexport const makePromise = toPromise;\n\nexport function fromPromise<T>(promise: Promise<T>): Observable<T> {\n  return new Observable<T>(observer => {\n    promise\n      .then((value: T) => {\n        observer.next(value);\n        observer.complete();\n      })\n      .catch(observer.error.bind(observer));\n  });\n}\n\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>(observer => {\n    observer.error(errorValue);\n  });\n}\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== 'string'\n        ? getOperationName(transformedOperation.query)\n        : '';\n  }\n\n  return transformedOperation as Operation;\n}\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest,\n): Operation {\n  let context = { ...starting };\n  const setContext = next => {\n    if (typeof next === 'function') {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext = () => ({ ...context });\n\n  Object.defineProperty(operation, 'setContext', {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, 'getContext', {\n    enumerable: false,\n    value: getContext,\n  });\n\n  Object.defineProperty(operation, 'toKey', {\n    enumerable: false,\n    value: () => getKey(operation),\n  });\n\n  return operation as Operation;\n}\n\nexport function getKey(operation: GraphQLRequest) {\n  // XXX We're assuming here that query and variables will be serialized in\n  // the same order, which might not always be true.\n  const { query, variables, operationName } = operation;\n  return JSON.stringify([operationName, query, variables]);\n}\n","import Observable from 'zen-observable-ts';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport {\n  GraphQLRequest,\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n} from './types';\n\nimport {\n  validateOperation,\n  isTerminating,\n  LinkError,\n  transformOperation,\n  createOperation,\n} from './linkUtils';\n\nfunction passthrough(op, forward) {\n  return forward ? forward(op) : Observable.of();\n}\n\nfunction toLink(handler: RequestHandler | ApolloLink) {\n  return typeof handler === 'function' ? new ApolloLink(handler) : handler;\n}\n\nexport function empty(): ApolloLink {\n  return new ApolloLink(() => Observable.of());\n}\n\nexport function from(links: ApolloLink[]): ApolloLink {\n  if (links.length === 0) return empty();\n  return links.map(toLink).reduce((x, y) => x.concat(y));\n}\n\nexport function split(\n  test: (op: Operation) => boolean,\n  left: ApolloLink | RequestHandler,\n  right?: ApolloLink | RequestHandler,\n): ApolloLink {\n  const leftLink = toLink(left);\n  const rightLink = toLink(right || new ApolloLink(passthrough));\n\n  if (isTerminating(leftLink) && isTerminating(rightLink)) {\n    return new ApolloLink(operation => {\n      return test(operation)\n        ? leftLink.request(operation) || Observable.of()\n        : rightLink.request(operation) || Observable.of();\n    });\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return test(operation)\n        ? leftLink.request(operation, forward) || Observable.of()\n        : rightLink.request(operation, forward) || Observable.of();\n    });\n  }\n}\n\n// join two Links together\nexport const concat = (\n  first: ApolloLink | RequestHandler,\n  second: ApolloLink | RequestHandler,\n) => {\n  const firstLink = toLink(first);\n  if (isTerminating(firstLink)) {\n    invariant.warn(\n      new LinkError(\n        `You are calling concat on a terminating link, which will have no effect`,\n        firstLink,\n      ),\n    );\n    return firstLink;\n  }\n  const nextLink = toLink(second);\n\n  if (isTerminating(nextLink)) {\n    return new ApolloLink(\n      operation =>\n        firstLink.request(\n          operation,\n          op => nextLink.request(op) || Observable.of(),\n        ) || Observable.of(),\n    );\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return (\n        firstLink.request(operation, op => {\n          return nextLink.request(op, forward) || Observable.of();\n        }) || Observable.of()\n      );\n    });\n  }\n};\n\nexport class ApolloLink {\n  public static empty = empty;\n  public static from = from;\n  public static split = split;\n  public static execute = execute;\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler,\n  ): ApolloLink {\n    return this.concat(split(test, left, right || new ApolloLink(passthrough)));\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    throw new InvariantError('request is not implemented');\n  }\n}\n\nexport function execute(\n  link: ApolloLink,\n  operation: GraphQLRequest,\n): Observable<FetchResult> {\n  return (\n    link.request(\n      createOperation(\n        operation.context,\n        transformOperation(validateOperation(operation)),\n      ),\n    ) || Observable.of()\n  );\n}\n","import { visit } from './visitor';\nimport { printBlockString } from './blockString';\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nexport function print(ast) {\n  return visit(ast, {\n    leave: printDocASTReducer\n  });\n} // TODO: provide better type coverage in future\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n  // Document\n  Document: function Document(node) {\n    return join(node.definitions, '\\n\\n') + '\\n';\n  },\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');\n  },\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue,\n        directives = _ref.directives;\n    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n  },\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');\n  },\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return name + ': ' + value;\n  },\n  // Fragments\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return '...' + name + wrap(' ', join(directives, ' '));\n  },\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (// Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      \"fragment \".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), \" \") + \"on \".concat(typeCondition, \" \").concat(wrap('', join(directives, ' '), ' ')) + selectionSet\n    );\n  },\n  // Value\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? printBlockString(value, key === 'description' ? '' : '  ') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return value ? 'true' : 'false';\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return name + ': ' + value;\n  },\n  // Directive\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return '@' + name + wrap('(', join(args, ', '), ')');\n  },\n  // Type\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n  // Type System Definitions\n  SchemaDefinition: function SchemaDefinition(_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return operation + ': ' + type;\n  },\n  ScalarTypeDefinition: addDescription(function (_ref22) {\n    var name = _ref22.name,\n        directives = _ref22.directives;\n    return join(['scalar', name, join(directives, ' ')], ' ');\n  }),\n  ObjectTypeDefinition: addDescription(function (_ref23) {\n    var name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  }),\n  FieldDefinition: addDescription(function (_ref24) {\n    var name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n  }),\n  InputValueDefinition: addDescription(function (_ref25) {\n    var name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n  }),\n  InterfaceTypeDefinition: addDescription(function (_ref26) {\n    var name = _ref26.name,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return join(['interface', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  UnionTypeDefinition: addDescription(function (_ref27) {\n    var name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  }),\n  EnumTypeDefinition: addDescription(function (_ref28) {\n    var name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return join(['enum', name, join(directives, ' '), block(values)], ' ');\n  }),\n  EnumValueDefinition: addDescription(function (_ref29) {\n    var name = _ref29.name,\n        directives = _ref29.directives;\n    return join([name, join(directives, ' ')], ' ');\n  }),\n  InputObjectTypeDefinition: addDescription(function (_ref30) {\n    var name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return join(['input', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  DirectiveDefinition: addDescription(function (_ref31) {\n    var name = _ref31.name,\n        args = _ref31.arguments,\n        repeatable = _ref31.repeatable,\n        locations = _ref31.locations;\n    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n  }),\n  SchemaExtension: function SchemaExtension(_ref32) {\n    var directives = _ref32.directives,\n        operationTypes = _ref32.operationTypes;\n    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives;\n    return join(['extend scalar', name, join(directives, ' ')], ' ');\n  },\n  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {\n    var name = _ref34.name,\n        interfaces = _ref34.interfaces,\n        directives = _ref34.directives,\n        fields = _ref34.fields;\n    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  },\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {\n    var name = _ref35.name,\n        directives = _ref35.directives,\n        fields = _ref35.fields;\n    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');\n  },\n  UnionTypeExtension: function UnionTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        types = _ref36.types;\n    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  },\n  EnumTypeExtension: function EnumTypeExtension(_ref37) {\n    var name = _ref37.name,\n        directives = _ref37.directives,\n        values = _ref37.values;\n    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n  },\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {\n    var name = _ref38.name,\n        directives = _ref38.directives,\n        fields = _ref38.fields;\n    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n  }\n};\n\nfunction addDescription(cb) {\n  return function (node) {\n    return join([node.description, cb(node)], '\\n');\n  };\n}\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? '{\\n' + indent(join(array, '\\n')) + '\\n}' : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\nfunction indent(maybeString) {\n  return maybeString && '  ' + maybeString.replace(/\\n/g, '\\n  ');\n}\n\nfunction isMultiline(string) {\n  return string.indexOf('\\n') !== -1;\n}\n\nfunction hasMultilineItems(maybeArray) {\n  return maybeArray && maybeArray.some(isMultiline);\n}\n","import React, { useContext } from 'react';\nvar ApolloContext = React.createContext(null);\nexport function ApolloProvider(_ref) {\n  var client = _ref.client,\n      children = _ref.children;\n  return React.createElement(ApolloContext.Provider, {\n    value: client\n  }, children);\n}\nexport function useApolloClient(overrideClient) {\n  var client = useContext(ApolloContext); // Ensures that the number of hooks called from one render to another remains\n  // constant, despite the Apollo client read from context being swapped for\n  // one passed directly as prop.\n\n  if (overrideClient) {\n    return overrideClient;\n  }\n\n  if (!client) {\n    // https://github.com/apollographql/react-apollo/blob/5cb63b3625ce5e4a3d3e4ba132eaec2a38ef5d90/src/component-utils.tsx#L19-L22\n    throw new Error('Could not find \"client\" in the context or passed in as a prop. ' + 'Wrap the root component in an <ApolloProvider>, or pass an ' + 'ApolloClient instance in via props.');\n  }\n\n  return client;\n}","export default function actHack(callback) {\n  callback();\n}","export default function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}","var parser = require('graphql/language/parser');\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","module.exports = require('./lib/Observable.js').Observable;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Observable = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// === Symbol Support ===\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\n\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\n\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type: type,\n      value: value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type: type,\n      value: value\n    }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription =\n/*#__PURE__*/\nfunction () {\n  function Subscription(observer, subscriber) {\n    _classCallCheck(this, Subscription);\n\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  _createClass(Subscription, [{\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      if (this._state !== 'closed') {\n        closeSubscription(this);\n        cleanupSubscription(this);\n      }\n    }\n  }, {\n    key: \"closed\",\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver =\n/*#__PURE__*/\nfunction () {\n  function SubscriptionObserver(subscription) {\n    _classCallCheck(this, SubscriptionObserver);\n\n    this._subscription = subscription;\n  }\n\n  _createClass(SubscriptionObserver, [{\n    key: \"next\",\n    value: function next(value) {\n      onNotify(this._subscription, 'next', value);\n    }\n  }, {\n    key: \"error\",\n    value: function error(value) {\n      onNotify(this._subscription, 'error', value);\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      onNotify(this._subscription, 'complete');\n    }\n  }, {\n    key: \"closed\",\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable =\n/*#__PURE__*/\nfunction () {\n  function Observable(subscriber) {\n    _classCallCheck(this, Observable);\n\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  _createClass(Observable, [{\n    key: \"subscribe\",\n    value: function subscribe(observer) {\n      if (typeof observer !== 'object' || observer === null) {\n        observer = {\n          next: observer,\n          error: arguments[1],\n          complete: arguments[2]\n        };\n      }\n\n      return new Subscription(observer, this._subscriber);\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== 'function') {\n          reject(new TypeError(fn + ' is not a function'));\n          return;\n        }\n\n        function done() {\n          subscription.unsubscribe();\n          resolve();\n        }\n\n        var subscription = _this.subscribe({\n          next: function (value) {\n            try {\n              fn(value, done);\n            } catch (e) {\n              reject(e);\n              subscription.unsubscribe();\n            }\n          },\n          error: reject,\n          complete: resolve\n        });\n      });\n    }\n  }, {\n    key: \"map\",\n    value: function map(fn) {\n      var _this2 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return _this2.subscribe({\n          next: function (value) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(fn) {\n      var _this3 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return _this3.subscribe({\n          next: function (value) {\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(fn) {\n      var _this4 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var seed = arguments[1];\n      var acc = seed;\n      return new C(function (observer) {\n        return _this4.subscribe({\n          next: function (value) {\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var _this5 = this;\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        var subscription;\n        var index = 0;\n\n        function startNext(next) {\n          subscription = next.subscribe({\n            next: function (v) {\n              observer.next(v);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              if (index === sources.length) {\n                subscription = undefined;\n                observer.complete();\n              } else {\n                startNext(C.from(sources[index++]));\n              }\n            }\n          });\n        }\n\n        startNext(_this5);\n        return function () {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        };\n      });\n    }\n  }, {\n    key: \"flatMap\",\n    value: function flatMap(fn) {\n      var _this6 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        var subscriptions = [];\n\n        var outer = _this6.subscribe({\n          next: function (value) {\n            if (fn) {\n              try {\n                value = fn(value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            }\n\n            var inner = C.from(value).subscribe({\n              next: function (value) {\n                observer.next(value);\n              },\n              error: function (e) {\n                observer.error(e);\n              },\n              complete: function () {\n                var i = subscriptions.indexOf(inner);\n                if (i >= 0) subscriptions.splice(i, 1);\n                completeIfDone();\n              }\n            });\n            subscriptions.push(inner);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            completeIfDone();\n          }\n        });\n\n        function completeIfDone() {\n          if (outer.closed && subscriptions.length === 0) observer.complete();\n        }\n\n        return function () {\n          subscriptions.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          outer.unsubscribe();\n        };\n      });\n    }\n  }, {\n    key: SymbolObservable,\n    value: function () {\n      return this;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(x) {\n      var C = typeof this === 'function' ? this : Observable;\n      if (x == null) throw new TypeError(x + ' is not an object');\n      var method = getMethod(x, SymbolObservable);\n\n      if (method) {\n        var observable = method.call(x);\n        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n        if (isObservable(observable) && observable.constructor === C) return observable;\n        return new C(function (observer) {\n          return observable.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol('iterator')) {\n        method = getMethod(x, SymbolIterator);\n\n        if (method) {\n          return new C(function (observer) {\n            enqueue(function () {\n              if (observer.closed) return;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var _item = _step.value;\n                  observer.next(_item);\n                  if (observer.closed) return;\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              observer.complete();\n            });\n          });\n        }\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n\n            for (var i = 0; i < x.length; ++i) {\n              observer.next(x[i]);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n\n      throw new TypeError(x + ' is not observable');\n    }\n  }, {\n    key: \"of\",\n    value: function of() {\n      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n\n      var C = typeof this === 'function' ? this : Observable;\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n\n          for (var i = 0; i < items.length; ++i) {\n            observer.next(items[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n  }, {\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nexports.Observable = Observable;\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}","'use strict';\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","export default function devAssert(condition, message) {\n  var booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\n","import nodejsCustomInspectSymbol from './nodejsCustomInspectSymbol';\n/**\n * The `defineToJSON()` function defines toJSON() and inspect() prototype\n * methods, if no function provided they become aliases for toString().\n */\n\nexport default function defineToJSON(classObject) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : classObject.prototype.toString;\n  classObject.prototype.toJSON = fn;\n  classObject.prototype.inspect = fn;\n\n  if (nodejsCustomInspectSymbol) {\n    classObject.prototype[nodejsCustomInspectSymbol] = fn;\n  }\n}\n","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport default function isObjectLike(value) {\n  return _typeof(value) == 'object' && value !== null;\n}\n","/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n","import { getLocation } from '../language/location';\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printLocation(location) {\n  return printSourceLocation(location.source, getLocation(location.source, location.start));\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = sourceLocation.line - 1;\n  var lineOffset = source.locationOffset.line - 1;\n  var lineNum = sourceLocation.line + lineOffset;\n  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  var columnNum = sourceLocation.column + columnOffset;\n  var locationStr = \"\".concat(source.name, \":\").concat(lineNum, \":\").concat(columnNum, \"\\n\");\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  var locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    var sublineIndex = Math.floor(columnNum / 80);\n    var sublineColumnNum = columnNum % 80;\n    var sublines = [];\n\n    for (var i = 0; i < locationLine.length; i += 80) {\n      sublines.push(locationLine.slice(i, i + 80));\n    }\n\n    return locationStr + printPrefixedLines([[\"\".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {\n      return ['', subline];\n    }), [[' ', whitespace(sublineColumnNum - 1) + '^'], ['', sublines[sublineIndex + 1]]]));\n  }\n\n  return locationStr + printPrefixedLines([// Lines specified like this: [\"prefix\", \"string\"],\n  [\"\".concat(lineNum - 1), lines[lineIndex - 1]], [\"\".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], [\"\".concat(lineNum + 1), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    var _ = _ref[0],\n        line = _ref[1];\n    return line !== undefined;\n  });\n  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {\n    var prefix = _ref2[0];\n    return prefix.length;\n  }));\n  return existingLines.map(function (_ref3) {\n    var prefix = _ref3[0],\n        line = _ref3[1];\n    return lpad(padLen, prefix) + (line ? ' | ' + line : ' |');\n  }).join('\\n');\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction lpad(len, str) {\n  return whitespace(len - str.length) + str;\n}\n","import isObjectLike from '../jsutils/isObjectLike';\nimport { getLocation } from '../language/location';\nimport { printLocation, printSourceLocation } from '../language/printLocation';\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport function GraphQLError( // eslint-disable-line no-redeclare\nmessage, nodes, source, positions, path, originalError, extensions) {\n  // Compute list of blame nodes.\n  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.\n\n\n  var _source = source;\n\n  if (!_source && _nodes) {\n    var node = _nodes[0];\n    _source = node && node.loc && node.loc.source;\n  }\n\n  var _positions = positions;\n\n  if (!_positions && _nodes) {\n    _positions = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(node.loc.start);\n      }\n\n      return list;\n    }, []);\n  }\n\n  if (_positions && _positions.length === 0) {\n    _positions = undefined;\n  }\n\n  var _locations;\n\n  if (positions && source) {\n    _locations = positions.map(function (pos) {\n      return getLocation(source, pos);\n    });\n  } else if (_nodes) {\n    _locations = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(getLocation(node.loc.source, node.loc.start));\n      }\n\n      return list;\n    }, []);\n  }\n\n  var _extensions = extensions;\n\n  if (_extensions == null && originalError != null) {\n    var originalExtensions = originalError.extensions;\n\n    if (isObjectLike(originalExtensions)) {\n      _extensions = originalExtensions;\n    }\n  }\n\n  Object.defineProperties(this, {\n    message: {\n      value: message,\n      // By being enumerable, JSON.stringify will include `message` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true,\n      writable: true\n    },\n    locations: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _locations || undefined,\n      // By being enumerable, JSON.stringify will include `locations` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_locations)\n    },\n    path: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: path || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(path)\n    },\n    nodes: {\n      value: _nodes || undefined\n    },\n    source: {\n      value: _source || undefined\n    },\n    positions: {\n      value: _positions || undefined\n    },\n    originalError: {\n      value: originalError\n    },\n    extensions: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _extensions || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_extensions)\n    }\n  }); // Include (non-enumerable) stack trace.\n\n  if (originalError && originalError.stack) {\n    Object.defineProperty(this, 'stack', {\n      value: originalError.stack,\n      writable: true,\n      configurable: true\n    });\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, GraphQLError);\n  } else {\n    Object.defineProperty(this, 'stack', {\n      value: Error().stack,\n      writable: true,\n      configurable: true\n    });\n  }\n}\nGraphQLError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: GraphQLError\n  },\n  name: {\n    value: 'GraphQLError'\n  },\n  toString: {\n    value: function toString() {\n      return printError(this);\n    }\n  }\n});\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\n\nexport function printError(error) {\n  var output = error.message;\n\n  if (error.nodes) {\n    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {\n      var node = _error$nodes2[_i2];\n\n      if (node.loc) {\n        output += '\\n\\n' + printLocation(node.loc);\n      }\n    }\n  } else if (error.source && error.locations) {\n    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {\n      var location = _error$locations2[_i4];\n      output += '\\n\\n' + printSourceLocation(error.source, location);\n    }\n  }\n\n  return output;\n}\n","import { GraphQLError } from './GraphQLError';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(\"Syntax Error: \".concat(description), undefined, source, [position]);\n}\n","/**\n * The set of allowed kind values for AST nodes.\n */\nexport var Kind = Object.freeze({\n  // Name\n  NAME: 'Name',\n  // Document\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  // Fragments\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  // Values\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  // Directives\n  DIRECTIVE: 'Directive',\n  // Types\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n  // Type System Definitions\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  // Type Definitions\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  // Directive Definitions\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  // Type System Extensions\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  // Type Extensions\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'\n});\n/**\n * The enum type representing the possible kind values of AST nodes.\n */\n","import devAssert from '../jsutils/devAssert';\nimport defineToStringTag from '../jsutils/defineToStringTag';\n\n/**\n * A representation of source input to GraphQL.\n * `name` and `locationOffset` are optional. They are useful for clients who\n * store GraphQL documents in source files; for example, if the GraphQL input\n * starts at line 40 in a file named Foo.graphql, it might be useful for name to\n * be \"Foo.graphql\" and location to be `{ line: 40, column: 0 }`.\n * line and column in locationOffset are 1-indexed\n */\nexport var Source = function Source(body, name, locationOffset) {\n  this.body = body;\n  this.name = name || 'GraphQL request';\n  this.locationOffset = locationOffset || {\n    line: 1,\n    column: 1\n  };\n  this.locationOffset.line > 0 || devAssert(0, 'line in locationOffset is 1-indexed and must be positive');\n  this.locationOffset.column > 0 || devAssert(0, 'column in locationOffset is 1-indexed and must be positive');\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(Source);\n","/**\n * The `defineToStringTag()` function checks first to see if the runtime\n * supports the `Symbol` class and then if the `Symbol.toStringTag` constant\n * is defined as a `Symbol` instance. If both conditions are met, the\n * Symbol.toStringTag property is defined as a getter that returns the\n * supplied class constructor's name.\n *\n * @method defineToStringTag\n *\n * @param {Class<any>} classObject a class such as Object, String, Number but\n * typically one of your own creation through the class keyword; `class A {}`,\n * for example.\n */\nexport default function defineToStringTag(classObject) {\n  if (typeof Symbol === 'function' && Symbol.toStringTag) {\n    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {\n      get: function get() {\n        return this.constructor.name;\n      }\n    });\n  }\n}\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport var TokenKind = Object.freeze({\n  SOF: '<SOF>',\n  EOF: '<EOF>',\n  BANG: '!',\n  DOLLAR: '$',\n  AMP: '&',\n  PAREN_L: '(',\n  PAREN_R: ')',\n  SPREAD: '...',\n  COLON: ':',\n  EQUALS: '=',\n  AT: '@',\n  BRACKET_L: '[',\n  BRACKET_R: ']',\n  BRACE_L: '{',\n  PIPE: '|',\n  BRACE_R: '}',\n  NAME: 'Name',\n  INT: 'Int',\n  FLOAT: 'Float',\n  STRING: 'String',\n  BLOCK_STRING: 'BlockString',\n  COMMENT: 'Comment'\n});\n/**\n * The enum type representing the token kinds values.\n */\n","import defineToJSON from '../jsutils/defineToJSON';\nimport { syntaxError } from '../error/syntaxError';\nimport { dedentBlockStringValue } from './blockString';\nimport { TokenKind } from './tokenKind';\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport function createLexer(source, options) {\n  var startOfFileToken = new Tok(TokenKind.SOF, 0, 0, 0, 0, null);\n  var lexer = {\n    source: source,\n    options: options,\n    lastToken: startOfFileToken,\n    token: startOfFileToken,\n    line: 1,\n    lineStart: 0,\n    advance: advanceLexer,\n    lookahead: lookahead\n  };\n  return lexer;\n}\n\nfunction advanceLexer() {\n  this.lastToken = this.token;\n  var token = this.token = this.lookahead();\n  return token;\n}\n\nfunction lookahead() {\n  var token = this.token;\n\n  if (token.kind !== TokenKind.EOF) {\n    do {\n      // Note: next is only mutable during parsing, so we cast to allow this.\n      token = token.next || (token.next = readToken(this, token));\n    } while (token.kind === TokenKind.COMMENT);\n  }\n\n  return token;\n}\n/**\n * The return type of createLexer.\n */\n\n\n// @internal\nexport function isPunctuatorToken(token) {\n  var kind = token.kind;\n  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;\n}\n/**\n * Helper function for constructing the Token object.\n */\n\nfunction Tok(kind, start, end, line, column, prev, value) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\ndefineToJSON(Tok, function () {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n});\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    \"\\\"\\\\u\".concat(('00' + code.toString(16).toUpperCase()).slice(-4), \"\\\"\")\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var pos = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n\n  if (pos >= bodyLength) {\n    return new Tok(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = body.charCodeAt(pos); // SourceCharacter\n\n  switch (code) {\n    // !\n    case 33:\n      return new Tok(TokenKind.BANG, pos, pos + 1, line, col, prev);\n    // #\n\n    case 35:\n      return readComment(source, pos, line, col, prev);\n    // $\n\n    case 36:\n      return new Tok(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);\n    // &\n\n    case 38:\n      return new Tok(TokenKind.AMP, pos, pos + 1, line, col, prev);\n    // (\n\n    case 40:\n      return new Tok(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);\n    // )\n\n    case 41:\n      return new Tok(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);\n    // .\n\n    case 46:\n      if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {\n        return new Tok(TokenKind.SPREAD, pos, pos + 3, line, col, prev);\n      }\n\n      break;\n    // :\n\n    case 58:\n      return new Tok(TokenKind.COLON, pos, pos + 1, line, col, prev);\n    // =\n\n    case 61:\n      return new Tok(TokenKind.EQUALS, pos, pos + 1, line, col, prev);\n    // @\n\n    case 64:\n      return new Tok(TokenKind.AT, pos, pos + 1, line, col, prev);\n    // [\n\n    case 91:\n      return new Tok(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);\n    // ]\n\n    case 93:\n      return new Tok(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);\n    // {\n\n    case 123:\n      return new Tok(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);\n    // |\n\n    case 124:\n      return new Tok(TokenKind.PIPE, pos, pos + 1, line, col, prev);\n    // }\n\n    case 125:\n      return new Tok(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);\n    // A-Z _ a-z\n\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return readName(source, pos, line, col, prev);\n    // - 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return readNumber(source, pos, code, line, col, prev);\n    // \"\n\n    case 34:\n      if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {\n        return readBlockString(source, pos, line, col, prev, lexer);\n      }\n\n      return readString(source, pos, line, col, prev);\n  }\n\n  throw syntaxError(source, pos, unexpectedCharacterMessage(code));\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n  }\n\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?';\n  }\n\n  return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n}\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * character, then returns the position of that character for lexing.\n */\n\n\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n\n  while (position < bodyLength) {\n    var code = body.charCodeAt(position); // tab | space | comma | BOM\n\n    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n\n  return position;\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code;\n  var position = start;\n\n  do {\n    code = body.charCodeAt(++position);\n  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Tok(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = body.charCodeAt(++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = body.charCodeAt(++position);\n\n    if (code >= 48 && code <= 57) {\n      throw syntaxError(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = body.charCodeAt(++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or e\n\n\n  if (code === 46 || code === 69 || code === 101) {\n    throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n  }\n\n  return new Tok(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = body.charCodeAt(++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += body.slice(chunkStart, position);\n      return new Tok(TokenKind.STRING, start, position + 1, line, col, prev, value);\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += body.slice(chunkStart, position - 1);\n      code = body.charCodeAt(position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          {\n            // uXXXX\n            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));\n\n            if (charCode < 0) {\n              var invalidSequence = body.slice(position + 1, position + 5);\n              throw syntaxError(source, position, \"Invalid character escape sequence: \\\\u\".concat(invalidSequence, \".\"));\n            }\n\n            value += String.fromCharCode(charCode);\n            position += 4;\n            break;\n          }\n\n        default:\n          throw syntaxError(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\n\n\nfunction readBlockString(source, start, line, col, prev, lexer) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n      rawValue += body.slice(chunkStart, position);\n      return new Tok(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if ( // Escape Triple-Quote (\\\"\"\")\n    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {\n      rawValue += body.slice(chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, start, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = start + 1;\n  var code = 0;\n\n  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++position;\n  }\n\n  return new Tok(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));\n}\n","/**\n * The set of allowed directive location values.\n */\nexport var DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */\n","import inspect from '../jsutils/inspect';\nimport devAssert from '../jsutils/devAssert';\nimport defineToJSON from '../jsutils/defineToJSON';\nimport { syntaxError } from '../error/syntaxError';\nimport { Kind } from './kinds';\nimport { Source } from './source';\nimport { createLexer } from './lexer';\nimport { DirectiveLocation } from './directiveLocation';\nimport { TokenKind } from './tokenKind';\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n\nvar Parser =\n/*#__PURE__*/\nfunction () {\n  function Parser(source, options) {\n    var sourceObj = typeof source === 'string' ? new Source(source) : source;\n    sourceObj instanceof Source || devAssert(0, \"Must provide Source. Received: \".concat(inspect(sourceObj)));\n    this._lexer = createLexer(sourceObj);\n    this._options = options || {};\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.experimentalFragmentVariables) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        if (token.value === 'true' || token.value === 'false') {\n          this._lexer.advance();\n\n          return {\n            kind: Kind.BOOLEAN,\n            value: token.value === 'true',\n            loc: this.loc(token)\n          };\n        } else if (token.value === 'null') {\n          this._lexer.advance();\n\n          return {\n            kind: Kind.NULL,\n            loc: this.loc(token)\n          };\n        }\n\n        this._lexer.advance();\n\n        return {\n          kind: Kind.ENUM,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n\n    if (this.expectOptionalKeyword('implements')) {\n      // Optional leading ampersand\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || // Legacy support for the SDL?\n      this._options.allowLegacySDLImplementsInterfaces && this.peek(TokenKind.NAME));\n    }\n\n    return types;\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    // Legacy support for the SDL?\n    if (this._options.allowLegacySDLEmptyFields && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      // Optional leading pipe\n      this.expectOptionalToken(TokenKind.PIPE);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.PIPE));\n    }\n\n    return types;\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *   - extend interface Name Directives[Const]? FieldsDefinition\n   *   - extend interface Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    // Optional leading pipe\n    this.expectOptionalToken(TokenKind.PIPE);\n    var locations = [];\n\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(TokenKind.PIPE));\n\n    return locations;\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    if (!this._options.noLocation) {\n      return new Loc(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(kind, \", found \").concat(getTokenDesc(token)));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token)));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken || this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token)));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\ndefineToJSON(Loc, function () {\n  return {\n    start: this.start,\n    end: this.end\n  };\n});\n/**\n * A helper function to describe a token as a string for debugging\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return value ? \"\".concat(token.kind, \" \\\"\").concat(value, \"\\\"\") : token.kind;\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nexport function queryFromPojo(obj: any): DocumentNode {\n  const op: OperationDefinitionNode = {\n    kind: 'OperationDefinition',\n    operation: 'query',\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [op],\n  };\n\n  return out;\n}\n\nexport function fragmentFromPojo(obj: any, typename?: string): DocumentNode {\n  const frag: FragmentDefinitionNode = {\n    kind: 'FragmentDefinition',\n    typeCondition: {\n      kind: 'NamedType',\n      name: {\n        kind: 'Name',\n        value: typename || '__FakeType',\n      },\n    },\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [frag],\n  };\n\n  return out;\n}\n\nfunction selectionSetFromObj(obj: any): SelectionSetNode {\n  if (\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    typeof obj === 'string' ||\n    typeof obj === 'undefined' ||\n    obj === null\n  ) {\n    // No selection set here\n    return null;\n  }\n\n  if (Array.isArray(obj)) {\n    // GraphQL queries don't include arrays\n    return selectionSetFromObj(obj[0]);\n  }\n\n  // Now we know it's an object\n  const selections: FieldNode[] = [];\n\n  Object.keys(obj).forEach(key => {\n    const nestedSelSet: SelectionSetNode = selectionSetFromObj(obj[key]);\n\n    const field: FieldNode = {\n      kind: 'Field',\n      name: {\n        kind: 'Name',\n        value: key,\n      },\n      selectionSet: nestedSelSet || undefined,\n    };\n\n    selections.push(field);\n  });\n\n  const selectionSet: SelectionSetNode = {\n    kind: 'SelectionSet',\n    selections,\n  };\n\n  return selectionSet;\n}\n\nexport const justTypenameQuery: DocumentNode = {\n  kind: 'Document',\n  definitions: [\n    {\n      kind: 'OperationDefinition',\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: [\n          {\n            kind: 'Field',\n            alias: null,\n            name: {\n              kind: 'Name',\n              value: '__typename',\n            },\n            arguments: [],\n            directives: [],\n            selectionSet: null,\n          },\n        ],\n      },\n    },\n  ],\n};\n","import { DataProxy } from './DataProxy';\n\nexport namespace Cache {\n  export type WatchCallback = (newData: any) => void;\n  export interface EvictionResult {\n    success: Boolean;\n  }\n\n  export interface ReadOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n    previousResult?: any;\n    optimistic: boolean;\n  }\n\n  export interface WriteOptions<TResult = any, TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    dataId: string;\n    result: TResult;\n  }\n\n  export interface DiffOptions extends ReadOptions {\n    returnPartialData?: boolean;\n  }\n\n  export interface WatchOptions extends ReadOptions {\n    callback: WatchCallback;\n  }\n\n  export interface EvictOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n  }\n\n  export import DiffResult = DataProxy.DiffResult;\n  export import WriteQueryOptions = DataProxy.WriteQueryOptions;\n  export import WriteFragmentOptions = DataProxy.WriteFragmentOptions;\n  export import WriteDataOptions = DataProxy.WriteDataOptions;\n  export import Fragment = DataProxy.Fragment;\n}\n","interface Node<K, V> {\n  key: K;\n  value: V;\n  newer: Node<K, V> | null;\n  older: Node<K, V> | null;\n}\n\nfunction defaultDispose() {}\n\nexport class Cache<K = any, V = any> {\n  private map = new Map<K, Node<K, V>>();\n  private newest: Node<K, V> | null = null;\n  private oldest: Node<K, V> | null = null;\n\n  constructor(\n    private max = Infinity,\n    public dispose: (value: V, key: K) => void = defaultDispose,\n  ) {}\n\n  public has(key: K) {\n    return this.map.has(key);\n  }\n\n  public get(key: K) {\n    const entry = this.getEntry(key);\n    return entry && entry.value;\n  }\n\n  private getEntry(key: K): Node<K, V> | void {\n    const entry = this.map.get(key);\n\n    if (entry && entry !== this.newest) {\n      const { older, newer } = entry;\n\n      if (newer) {\n        newer.older = older;\n      }\n\n      if (older) {\n        older.newer = newer;\n      }\n\n      entry.older = this.newest;\n      entry.older!.newer = entry;\n\n      entry.newer = null;\n      this.newest = entry;\n\n      if (entry === this.oldest) {\n        this.oldest = newer;\n      }\n    }\n\n    return entry;\n  }\n\n  public set(key: K, value: V) {\n    let entry = this.getEntry(key);\n    if (entry) {\n      return entry.value = value;\n    }\n\n    entry = {\n      key: key,\n      value: value,\n      newer: null,\n      older: this.newest\n    };\n\n    if (this.newest) {\n      this.newest.newer = entry;\n    }\n\n    this.newest = entry;\n    this.oldest = this.oldest || entry;\n\n    this.map.set(key, entry);\n\n    return entry.value;\n  }\n\n  public clean() {\n    while (this.oldest && this.map.size > this.max) {\n      this.delete(this.oldest.key);\n    }\n  }\n\n  public delete(key: K) {\n    const entry = this.map.get(key);\n    if (entry) {\n      if (entry === this.newest) {\n        this.newest = entry.older;\n      }\n\n      if (entry === this.oldest) {\n        this.oldest = entry.newer;\n      }\n\n      if (entry.newer) {\n        entry.newer.older = entry.older;\n      }\n\n      if (entry.older) {\n        entry.older.newer = entry.newer;\n      }\n\n      this.map.delete(key);\n      this.dispose(entry.value, key);\n\n      return true;\n    }\n\n    return false;\n  }\n}\n","type Context = {\n  parent: Context | null;\n  slots: { [slotId: string]: any };\n}\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext: Context | null = null;\n\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE: any = {};\n\nlet idCounter = 1;\n\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot<TValue> {\n  // If you have a Slot object, you can find out its slot.id, but you cannot\n  // guess the slot.id of a Slot you don't have access to, thanks to the\n  // randomized suffix.\n  public readonly id = [\n    \"slot\",\n    idCounter++,\n    Date.now(),\n    Math.random().toString(36).slice(2),\n  ].join(\":\");\n\n  public hasValue() {\n    for (let context = currentContext; context; context = context.parent) {\n      // We use the Slot object iself as a key to its value, which means the\n      // value cannot be obtained without a reference to the Slot object.\n      if (this.id in context.slots) {\n        const value = context.slots[this.id];\n        if (value === MISSING_VALUE) break;\n        if (context !== currentContext) {\n          // Cache the value in currentContext.slots so the next lookup will\n          // be faster. This caching is safe because the tree of contexts and\n          // the values of the slots are logically immutable.\n          currentContext!.slots[this.id] = value;\n        }\n        return true;\n      }\n    }\n    if (currentContext) {\n      // If a value was not found for this Slot, it's never going to be found\n      // no matter how many times we look it up, so we might as well cache\n      // the absence of the value, too.\n      currentContext.slots[this.id] = MISSING_VALUE;\n    }\n    return false;\n  }\n\n  public getValue(): TValue | undefined {\n    if (this.hasValue()) {\n      return currentContext!.slots[this.id] as TValue;\n    }\n  }\n\n  public withValue<TResult, TArgs extends any[], TThis = any>(\n    value: TValue,\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ): TResult {\n    const slots = {\n      __proto__: null,\n      [this.id]: value,\n    };\n    const parent = currentContext;\n    currentContext = { parent, slots };\n    try {\n      // Function.prototype.apply allows the arguments array argument to be\n      // omitted or undefined, so args! is fine here.\n      return callback.apply(thisArg!, args!);\n    } finally {\n      currentContext = parent;\n    }\n  }\n\n  // Capture the current context and wrap a callback function so that it\n  // reestablishes the captured context when called.\n  static bind<TArgs extends any[], TResult>(\n    callback: (...args: TArgs) => TResult,\n  ) {\n    const context = currentContext;\n    return function (this: any) {\n      const saved = currentContext;\n      try {\n        currentContext = context;\n        return callback.apply(this, arguments as any);\n      } finally {\n        currentContext = saved;\n      }\n    } as typeof callback;\n  }\n\n  // Immediately run a callback function without any captured context.\n  static noContext<TResult, TArgs extends any[], TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ) {\n    if (currentContext) {\n      const saved = currentContext;\n      try {\n        currentContext = null;\n        // Function.prototype.apply allows the arguments array argument to be\n        // omitted or undefined, so args! is fine here.\n        return callback.apply(thisArg!, args!);\n      } finally {\n        currentContext = saved;\n      }\n    } else {\n      return callback.apply(thisArg!, args!);\n    }\n  }\n};\n\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable symbol property of the Array constructor. This obfuscation\n// does nothing to prevent access to the Slot class, but at least it ensures\n// the implementation (i.e. currentContext) cannot be tampered with, and all\n// copies of the @wry/context package (hopefully just one) will share the\n// same Slot implementation. Since the first copy of the @wry/context package\n// to be imported wins, this technique imposes a very high cost for any\n// future breaking changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\nconst host = Array as any;\n\nexport const Slot: ReturnType<typeof makeSlotClass> = host[globalKey] || function () {\n  const Slot = makeSlotClass();\n  try {\n    Object.defineProperty(host, globalKey, {\n      value: host[globalKey] = Slot,\n      enumerable: false,\n      writable: false,\n      configurable: false,\n    });\n  } finally {\n    return Slot;\n  }\n}();\n","import { AnyEntry } from \"./entry\";\nimport { Slot } from \"@wry/context\";\n\nexport const parentEntrySlot = new Slot<AnyEntry>();\n\nexport {\n  bind as bindContext,\n  noContext,\n  setTimeout,\n  asyncFromGen,\n} from \"@wry/context\";\n","import { parentEntrySlot } from \"./context\";\nimport { OptimisticWrapOptions } from \"./index\";\n\nconst reusableEmptyArray: AnyEntry[] = [];\nconst emptySetPool: Set<AnyEntry>[] = [];\nconst POOL_TARGET_SIZE = 100;\n\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition: any, optionalMessage?: string) {\n  if (! condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\n// Since exceptions are cached just like normal values, we need an efficient\n// way of representing unknown, ordinary, and exceptional values.\ntype Value<T> =\n  | []           // unknown\n  | [T]          // known value\n  | [void, any]; // known exception\n\nfunction valueIs(a: Value<any>, b: Value<any>) {\n  const len = a.length;\n  return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n    // Both values must be ordinary (or both exceptional) to be equal.\n    len === b.length &&\n    // The underlying value or exception must be the same.\n    a[len - 1] === b[len - 1]\n  );\n}\n\nfunction valueGet<T>(value: Value<T>): T {\n  switch (value.length) {\n    case 0: throw new Error(\"unknown value\");\n    case 1: return value[0];\n    case 2: throw value[1];\n  }\n}\n\nfunction valueCopy<T>(value: Value<T>): Value<T> {\n  return value.slice(0) as Value<T>;\n}\n\nexport type AnyEntry = Entry<any, any>;\n\nexport class Entry<TArgs extends any[], TValue> {\n  public static count = 0;\n\n  public subscribe: OptimisticWrapOptions<TArgs>[\"subscribe\"];\n  public unsubscribe?: () => any;\n  public reportOrphan?: (this: Entry<TArgs, TValue>) => any;\n\n  public readonly parents = new Set<AnyEntry>();\n  public readonly childValues = new Map<AnyEntry, Value<any>>();\n\n  // When this Entry has children that are dirty, this property becomes\n  // a Set containing other Entry objects, borrowed from emptySetPool.\n  // When the set becomes empty, it gets recycled back to emptySetPool.\n  public dirtyChildren: Set<AnyEntry> | null = null;\n\n  public dirty = true;\n  public recomputing = false;\n  public readonly value: Value<TValue> = [];\n\n  constructor(\n    public readonly fn: (...args: TArgs) => TValue,\n    public args: TArgs,\n  ) {\n    ++Entry.count;\n  }\n\n  // This is the most important method of the Entry API, because it\n  // determines whether the cached this.value can be returned immediately,\n  // or must be recomputed. The overall performance of the caching system\n  // depends on the truth of the following observations: (1) this.dirty is\n  // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n  // (3) valueGet(this.value) is usually returned without recomputation.\n  public recompute(): TValue {\n    assert(! this.recomputing, \"already recomputing\");\n\n    if (! rememberParent(this) && maybeReportOrphan(this)) {\n      // The recipient of the entry.reportOrphan callback decided to dispose\n      // of this orphan entry by calling entry.dispose(), so we don't need to\n      // (and should not) proceed with the recomputation.\n      return void 0 as any;\n    }\n\n    return mightBeDirty(this)\n      ? reallyRecompute(this)\n      : valueGet(this.value);\n  }\n\n  public setDirty() {\n    if (this.dirty) return;\n    this.dirty = true;\n    this.value.length = 0;\n    reportDirty(this);\n    // We can go ahead and unsubscribe here, since any further dirty\n    // notifications we receive will be redundant, and unsubscribing may\n    // free up some resources, e.g. file watchers.\n    maybeUnsubscribe(this);\n  }\n\n  public dispose() {\n    forgetChildren(this).forEach(maybeReportOrphan);\n    maybeUnsubscribe(this);\n\n    // Because this entry has been kicked out of the cache (in index.js),\n    // we've lost the ability to find out if/when this entry becomes dirty,\n    // whether that happens through a subscription, because of a direct call\n    // to entry.setDirty(), or because one of its children becomes dirty.\n    // Because of this loss of future information, we have to assume the\n    // worst (that this entry might have become dirty very soon), so we must\n    // immediately mark this entry's parents as dirty. Normally we could\n    // just call entry.setDirty() rather than calling parent.setDirty() for\n    // each parent, but that would leave this entry in parent.childValues\n    // and parent.dirtyChildren, which would prevent the child from being\n    // truly forgotten.\n    this.parents.forEach(parent => {\n      parent.setDirty();\n      forgetChild(parent, this);\n    });\n  }\n}\n\nfunction rememberParent(child: AnyEntry) {\n  const parent = parentEntrySlot.getValue();\n  if (parent) {\n    child.parents.add(parent);\n\n    if (! parent.childValues.has(child)) {\n      parent.childValues.set(child, []);\n    }\n\n    if (mightBeDirty(child)) {\n      reportDirtyChild(parent, child);\n    } else {\n      reportCleanChild(parent, child);\n    }\n\n    return parent;\n  }\n}\n\nfunction reallyRecompute(entry: AnyEntry) {\n  // Since this recomputation is likely to re-remember some of this\n  // entry's children, we forget our children here but do not call\n  // maybeReportOrphan until after the recomputation finishes.\n  const originalChildren = forgetChildren(entry);\n\n  // Set entry as the parent entry while calling recomputeNewValue(entry).\n  parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);\n\n  if (maybeSubscribe(entry)) {\n    // If we successfully recomputed entry.value and did not fail to\n    // (re)subscribe, then this Entry is no longer explicitly dirty.\n    setClean(entry);\n  }\n\n  // Now that we've had a chance to re-remember any children that were\n  // involved in the recomputation, we can safely report any orphan\n  // children that remain.\n  originalChildren.forEach(maybeReportOrphan);\n\n  return valueGet(entry.value);\n}\n\nfunction recomputeNewValue(entry: AnyEntry) {\n  entry.recomputing = true;\n  // Set entry.value as unknown.\n  entry.value.length = 0;\n  try {\n    // If entry.fn succeeds, entry.value will become a normal Value.\n    entry.value[0] = entry.fn.apply(null, entry.args);\n  } catch (e) {\n    // If entry.fn throws, entry.value will become exceptional.\n    entry.value[1] = e;\n  }\n  // Either way, this line is always reached.\n  entry.recomputing = false;\n}\n\nfunction mightBeDirty(entry: AnyEntry) {\n  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\n\nfunction setClean(entry: AnyEntry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(child: AnyEntry) {\n  child.parents.forEach(parent => reportDirtyChild(parent, child));\n}\n\nfunction reportClean(child: AnyEntry) {\n  child.parents.forEach(parent => reportCleanChild(parent, child));\n}\n\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(mightBeDirty(child));\n\n  if (! parent.dirtyChildren) {\n    parent.dirtyChildren = emptySetPool.pop() || new Set;\n\n  } else if (parent.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  parent.dirtyChildren.add(child);\n  reportDirty(parent);\n}\n\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(! mightBeDirty(child));\n\n  const childValue = parent.childValues.get(child)!;\n  if (childValue.length === 0) {\n    parent.childValues.set(child, valueCopy(child.value));\n  } else if (! valueIs(childValue, child.value)) {\n    parent.setDirty();\n  }\n\n  removeDirtyChild(parent, child);\n\n  if (mightBeDirty(parent)) {\n    return;\n  }\n\n  reportClean(parent);\n}\n\nfunction removeDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  const dc = parent.dirtyChildren;\n  if (dc) {\n    dc.delete(child);\n    if (dc.size === 0) {\n      if (emptySetPool.length < POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n      parent.dirtyChildren = null;\n    }\n  }\n}\n\n// If the given entry has a reportOrphan method, and no remaining parents,\n// call entry.reportOrphan and return true iff it returns true. The\n// reportOrphan function should return true to indicate entry.dispose()\n// has been called, and the entry has been removed from any other caches\n// (see index.js for the only current example).\nfunction maybeReportOrphan(entry: AnyEntry) {\n  return entry.parents.size === 0 &&\n    typeof entry.reportOrphan === \"function\" &&\n    entry.reportOrphan() === true;\n}\n\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent: AnyEntry) {\n  let children = reusableEmptyArray;\n\n  if (parent.childValues.size > 0) {\n    children = [];\n    parent.childValues.forEach((_value, child) => {\n      forgetChild(parent, child);\n      children.push(child);\n    });\n  }\n\n  // After we forget all our children, this.dirtyChildren must be empty\n  // and therefore must have been reset to null.\n  assert(parent.dirtyChildren === null);\n\n  return children;\n}\n\nfunction forgetChild(parent: AnyEntry, child: AnyEntry) {\n  child.parents.delete(parent);\n  parent.childValues.delete(child);\n  removeDirtyChild(parent, child);\n}\n\nfunction maybeSubscribe(entry: AnyEntry) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      maybeUnsubscribe(entry); // Prevent double subscriptions.\n      entry.unsubscribe = entry.subscribe.apply(null, entry.args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  }\n\n  // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n  return true;\n}\n\nfunction maybeUnsubscribe(entry: AnyEntry) {\n  const { unsubscribe } = entry;\n  if (typeof unsubscribe === \"function\") {\n    entry.unsubscribe = void 0;\n    unsubscribe();\n  }\n}\n","// A trie data structure that holds object keys weakly, yet can also hold\n// non-object keys, unlike the native `WeakMap`.\nexport class KeyTrie<K> {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  private weak?: WeakMap<any, KeyTrie<K>>;\n  private strong?: Map<any, KeyTrie<K>>;\n  private data?: K;\n\n  constructor(private readonly weakness: boolean) {}\n\n  public lookup<T extends any[]>(...array: T): K {\n    return this.lookupArray(array);\n  }\n\n  public lookupArray<T extends any[]>(array: T): K {\n    let node: KeyTrie<K> = this;\n    array.forEach(key => node = node.getChildTrie(key));\n    return node.data || (node.data = Object.create(null));\n  }\n\n  private getChildTrie(key: any) {\n    const map = this.weakness && isObjRef(key)\n      ? this.weak || (this.weak = new WeakMap<any, KeyTrie<K>>())\n      : this.strong || (this.strong = new Map<any, KeyTrie<K>>());\n    let child = map.get(key);\n    if (!child) map.set(key, child = new KeyTrie<K>(this.weakness));\n    return child;\n  }\n}\n\nfunction isObjRef(value: any) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) break;\n    // Fall through to return true...\n  case \"function\":\n    return true;\n  }\n  return false;\n}\n","import { Operation } from 'apollo-link';\nimport { print } from 'graphql/language/printer';\nimport { InvariantError } from 'ts-invariant';\n\n/*\n * Http Utilities: shared across links that make http requests\n */\n\n// XXX replace with actual typings when available\ndeclare var AbortController: any;\n\n//Used for any Error for data from the server\n//on a request with a Status >= 300\n//response contains no data or errors\nexport type ServerError = Error & {\n  response: Response;\n  result: Record<string, any>;\n  statusCode: number;\n};\n\n//Thrown when server's resonse is cannot be parsed\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport type ClientParseError = InvariantError & {\n  parseError: Error;\n};\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: any; //overrides headers in options\n  credentials?: any;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\n// The body of a GraphQL-over-HTTP-POST request.\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: WindowOrWorkerGlobalScope['fetch'];\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: any;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: '*/*',\n  'content-type': 'application/json',\n};\n\nconst defaultOptions = {\n  method: 'POST',\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const throwServerError = (response, result, message) => {\n  const error = new Error(message) as ServerError;\n\n  error.name = 'ServerError';\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n\n  throw error;\n};\n\n//TODO: when conditional types come in ts 2.8, operations should be a generic type that extends Operation | Array<Operation>\nexport const parseAndCheckHttpResponse = operations => (response: Response) => {\n  return (\n    response\n      .text()\n      .then(bodyText => {\n        try {\n          return JSON.parse(bodyText);\n        } catch (err) {\n          const parseError = err as ServerParseError;\n          parseError.name = 'ServerParseError';\n          parseError.response = response;\n          parseError.statusCode = response.status;\n          parseError.bodyText = bodyText;\n          return Promise.reject(parseError);\n        }\n      })\n      //TODO: when conditional types come out then result should be T extends Array ? Array<FetchResult> : FetchResult\n      .then((result: any) => {\n        if (response.status >= 300) {\n          //Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`,\n          );\n        }\n        //TODO should really error per response in a Batch based on properties\n        //    - could be done in a validation link\n        if (\n          !Array.isArray(result) &&\n          !result.hasOwnProperty('data') &&\n          !result.hasOwnProperty('errors')\n        ) {\n          //Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map(op => op.operationName)\n                : operations.operationName\n            }'.`,\n          );\n        }\n        return result;\n      })\n  );\n};\n\nexport const checkFetcher = (fetcher: WindowOrWorkerGlobalScope['fetch']) => {\n  if (!fetcher && typeof fetch === 'undefined') {\n    let library: string = 'unfetch';\n    if (typeof window === 'undefined') library = 'node-fetch';\n    throw new InvariantError(`\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/${library}.\n\nFor example:\nimport fetch from '${library}';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });`);\n  }\n};\n\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === 'undefined')\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n\nexport const selectHttpOptionsAndBody = (\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) => {\n  let options: HttpConfig & Record<string, any> = {\n    ...fallbackConfig.options,\n    headers: fallbackConfig.headers,\n    credentials: fallbackConfig.credentials,\n  };\n  let http: HttpQueryOptions = fallbackConfig.http;\n\n  /*\n   * use the rest of the configs to populate the options\n   * configs later in the list will overwrite earlier fields\n   */\n  configs.forEach(config => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n    if (config.credentials) options.credentials = config.credentials;\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = print(query);\n\n  return {\n    options,\n    body,\n  };\n};\n\nexport const serializeFetchParameter = (p, label) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e) {\n    const parseError = new InvariantError(\n      `Network request failed. ${label} is not serializable: ${e.message}`,\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n\n//selects \"/graphql\" by default\nexport const selectURI = (\n  operation,\n  fallbackURI?: string | ((operation: Operation) => string),\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === 'function') {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || '/graphql';\n  }\n};\n","import { isTest, IdValue } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\nfunction shouldWarn() {\n  const answer = !haveWarned;\n  /* istanbul ignore if */\n  if (!isTest()) {\n    haveWarned = true;\n  }\n  return answer;\n}\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean | 'heuristic' {\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/3507\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    if (!__typename) {\n      if (shouldWarn()) {\n        invariant.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        invariant.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        invariant.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n      }\n\n      return 'heuristic';\n    }\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    // At this point we don't know if this fragment should match or not. It's\n    // either:\n    //\n    // 1. (GOOD) A fragment on a matching interface or union.\n    // 2. (BAD) A fragment on a non-matching concrete type or interface or union.\n    //\n    // If it's 2, we don't want it to match. If it's 1, we want it to match. We\n    // can't tell the difference, so we warn the user, but still try to match\n    // it (for backwards compatibility reasons). This unfortunately means that\n    // using the `HeuristicFragmentMatcher` with unions and interfaces is\n    // very unreliable. This will be addressed in a future major version of\n    // Apollo Client, but for now the recommendation is to use the\n    // `IntrospectionFragmentMatcher` when working with unions/interfaces.\n\n    if (shouldWarn()) {\n      invariant.error(\n        'You are using the simple (heuristic) fragment matcher, but your ' +\n          'queries contain union or interface types. Apollo Client will not be ' +\n          'able to accurately map fragments. To make this error go away, use ' +\n          'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n          'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher',\n      );\n    }\n\n    return 'heuristic';\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    invariant(\n      this.isReady,\n      'FragmentMatcher.match() was called before FragmentMatcher.init()',\n    );\n\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/4620\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    invariant(\n      __typename,\n      `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n        obj,\n      )}`,\n    );\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (\n      __typename &&\n      implementingTypes &&\n      implementingTypes.indexOf(__typename) > -1\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class DepTrackingCache implements NormalizedCache {\n  // Wrapper function produced by the optimism library, used to depend on\n  // dataId strings, for easy invalidation of specific IDs.\n  private depend: OptimisticWrapperFunction<[string], StoreObject | undefined>;\n\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {\n    this.depend = wrap((dataId: string) => this.data[dataId], {\n      disposable: true,\n      makeCacheKey(dataId: string) {\n        return dataId;\n      },\n    });\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n\n  public get(dataId: string): StoreObject {\n    this.depend(dataId);\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value?: StoreObject) {\n    const oldValue = this.data[dataId];\n    if (value !== oldValue) {\n      this.data[dataId] = value;\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public delete(dataId: string): void {\n    if (hasOwn.call(this.data, dataId)) {\n      delete this.data[dataId];\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    if (newData) {\n      Object.keys(newData).forEach(dataId => {\n        this.set(dataId, newData[dataId]);\n      });\n      Object.keys(this.data).forEach(dataId => {\n        if (!hasOwn.call(newData, dataId)) {\n          this.delete(dataId);\n        }\n      });\n    } else {\n      Object.keys(this.data).forEach(dataId => {\n        this.delete(dataId);\n      });\n    }\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new DepTrackingCache(seed);\n}\n","import {\n  argumentsObjectFromField,\n  assign,\n  canUseWeakMap,\n  createFragmentMap,\n  DirectiveInfo,\n  FragmentMap,\n  getDefaultValues,\n  getDirectiveInfoFromField,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getQueryDefinition,\n  getStoreKeyName,\n  IdValue,\n  isEqual,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isJsonValue,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  resultKeyNameFromField,\n  shouldInclude,\n  StoreValue,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n  ReadQueryOptions,\n  StoreObject,\n} from './types';\n\nimport {\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { wrap, KeyTrie } from 'optimism';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: ReadStoreContext,\n) => boolean | 'heuristic';\n\ntype ExecContext = {\n  query: DocumentNode;\n  fragmentMap: FragmentMap;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n};\n\ntype ExecInfo = {\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecResultMissingField = {\n  object: StoreObject;\n  fieldName: string;\n  tolerable: boolean;\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  // Empty array if no missing fields encountered while computing result.\n  missing?: ExecResultMissingField[];\n};\n\ntype ExecStoreQueryOptions = {\n  query: DocumentNode;\n  rootValue: IdValue;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  // Default matcher always matches all fragments\n  fragmentMatcher?: FragmentMatcher;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  rootValue: any;\n  execContext: ExecContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: any[];\n  execContext: ExecContext;\n};\n\nexport interface StoreReaderConfig {\n  cacheKeyRoot?: KeyTrie<object>;\n  freezeResults?: boolean;\n}\n\nexport class StoreReader {\n  private freezeResults: boolean;\n\n  constructor({\n    cacheKeyRoot = new KeyTrie<object>(canUseWeakMap),\n    freezeResults = false,\n  }: StoreReaderConfig = {}) {\n    const {\n      executeStoreQuery,\n      executeSelectionSet,\n      executeSubSelectedArray,\n    } = this;\n\n    this.freezeResults = freezeResults;\n\n    this.executeStoreQuery = wrap((options: ExecStoreQueryOptions) => {\n      return executeStoreQuery.call(this, options);\n    }, {\n      makeCacheKey({\n        query,\n        rootValue,\n        contextValue,\n        variableValues,\n        fragmentMatcher,\n      }: ExecStoreQueryOptions) {\n        // The result of executeStoreQuery can be safely cached only if the\n        // underlying store is capable of tracking dependencies and invalidating\n        // the cache when relevant data have changed.\n        if (contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            contextValue.store,\n            query,\n            fragmentMatcher,\n            JSON.stringify(variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSelectionSet = wrap((options: ExecSelectionSetOptions) => {\n      return executeSelectionSet.call(this, options);\n    }, {\n      makeCacheKey({\n        selectionSet,\n        rootValue,\n        execContext,\n      }: ExecSelectionSetOptions) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            selectionSet,\n            execContext.fragmentMatcher,\n            JSON.stringify(execContext.variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n      return executeSubSelectedArray.call(this, options);\n    }, {\n      makeCacheKey({ field, array, execContext }) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            field,\n            array,\n            JSON.stringify(execContext.variableValues),\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Resolves the result of a query solely from the store (i.e. never hits the server).\n   *\n   * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n   * store.\n   *\n   * @param {DocumentNode} query The query document to resolve from the data available in the store.\n   *\n   * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n   * be referenced by the query document.\n   *\n   * @param {any} previousResult The previous result returned by this function for the same query.\n   * If nothing in the store changed since that previous result then values from the previous result\n   * will be returned to preserve referential equality.\n   */\n  public readQueryFromStore<QueryType>(\n    options: ReadQueryOptions,\n  ): QueryType | undefined {\n    return this.diffQueryAgainstStore<QueryType>({\n      ...options,\n      returnPartialData: false,\n    }).result;\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @param  {any} previousResult The previous result returned by this function for the same query\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    variables,\n    previousResult,\n    returnPartialData = true,\n    rootId = 'ROOT_QUERY',\n    fragmentMatcherFunction,\n    config,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    // Throw the right validation error by trying to find a query in the document\n    const queryDefinition = getQueryDefinition(query);\n\n    variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n    const context: ReadStoreContext = {\n      // Global settings\n      store,\n      dataIdFromObject: config && config.dataIdFromObject,\n      cacheRedirects: (config && config.cacheRedirects) || {},\n    };\n\n    const execResult = this.executeStoreQuery({\n      query,\n      rootValue: {\n        type: 'id',\n        id: rootId,\n        generated: true,\n        typename: 'Query',\n      },\n      contextValue: context,\n      variableValues: variables,\n      fragmentMatcher: fragmentMatcherFunction,\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n\n    if (hasMissingFields && ! returnPartialData) {\n      execResult.missing!.forEach(info => {\n        if (info.tolerable) return;\n        throw new InvariantError(\n          `Can't find field ${info.fieldName} on object ${JSON.stringify(\n            info.object,\n            null,\n            2,\n          )}.`,\n        );\n      });\n    }\n\n    if (previousResult) {\n      if (isEqual(previousResult, execResult.result)) {\n        execResult.result = previousResult;\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !hasMissingFields,\n    };\n  }\n\n  /**\n   * Based on graphql function from graphql-js:\n   *\n   * graphql(\n   *   schema: GraphQLSchema,\n   *   requestString: string,\n   *   rootValue?: ?any,\n   *   contextValue?: ?any,\n   *   variableValues?: ?{[key: string]: any},\n   *   operationName?: ?string\n   * ): Promise<GraphQLResult>\n   *\n   * The default export as of graphql-anywhere is sync as of 4.0,\n   * but below is an exported alternative that is async.\n   * In the 5.0 version, this will be the only export again\n   * and it will be async\n   *\n   */\n  private executeStoreQuery({\n    query,\n    rootValue,\n    contextValue,\n    variableValues,\n    // Default matcher always matches all fragments\n    fragmentMatcher = defaultFragmentMatcher,\n  }: ExecStoreQueryOptions): ExecResult {\n    const mainDefinition = getMainDefinition(query);\n    const fragments = getFragmentDefinitions(query);\n    const fragmentMap = createFragmentMap(fragments);\n    const execContext: ExecContext = {\n      query,\n      fragmentMap,\n      contextValue,\n      variableValues,\n      fragmentMatcher,\n    };\n\n    return this.executeSelectionSet({\n      selectionSet: mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    });\n  }\n\n  private executeSelectionSet({\n    selectionSet,\n    rootValue,\n    execContext,\n  }: ExecSelectionSetOptions): ExecResult {\n    const { fragmentMap, contextValue, variableValues: variables } = execContext;\n    const finalResult: ExecResult = { result: null };\n\n    const objectsToMerge: { [key: string]: any }[] = [];\n\n    const object: StoreObject = contextValue.store.get(rootValue.id);\n\n    const typename =\n      (object && object.__typename) ||\n      (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n      void 0;\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) {\n        finalResult.missing = finalResult.missing || [];\n        finalResult.missing.push(...result.missing);\n      }\n      return result.result;\n    }\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely\n        return;\n      }\n\n      if (isField(selection)) {\n        const fieldResult = handleMissing(\n          this.executeField(object, typename, selection, execContext),\n        );\n\n        if (typeof fieldResult !== 'undefined') {\n          objectsToMerge.push({\n            [resultKeyNameFromField(selection)]: fieldResult,\n          });\n        }\n\n      } else {\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // This is a named fragment\n          fragment = fragmentMap[selection.name.value];\n\n          if (!fragment) {\n            throw new InvariantError(`No fragment named ${selection.name.value}`);\n          }\n        }\n\n        const typeCondition =\n          fragment.typeCondition && fragment.typeCondition.name.value;\n\n        const match =\n          !typeCondition ||\n          execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n\n        if (match) {\n          let fragmentExecResult = this.executeSelectionSet({\n            selectionSet: fragment.selectionSet,\n            rootValue,\n            execContext,\n          });\n\n          if (match === 'heuristic' && fragmentExecResult.missing) {\n            fragmentExecResult = {\n              ...fragmentExecResult,\n              missing: fragmentExecResult.missing.map(info => {\n                return { ...info, tolerable: true };\n              }),\n            };\n          }\n\n          objectsToMerge.push(handleMissing(fragmentExecResult));\n        }\n      }\n    });\n\n    // Perform a single merge at the end so that we can avoid making more\n    // defensive shallow copies than necessary.\n    finalResult.result = mergeDeepArray(objectsToMerge);\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n\n    return finalResult;\n  }\n\n  private executeField(\n    object: StoreObject,\n    typename: string | void,\n    field: FieldNode,\n    execContext: ExecContext,\n  ): ExecResult {\n    const { variableValues: variables, contextValue } = execContext;\n    const fieldName = field.name.value;\n    const args = argumentsObjectFromField(field, variables);\n\n    const info: ExecInfo = {\n      resultKey: resultKeyNameFromField(field),\n      directives: getDirectiveInfoFromField(field, variables),\n    };\n\n    const readStoreResult = readStoreResolver(\n      object,\n      typename,\n      fieldName,\n      args,\n      contextValue,\n      info,\n    );\n\n    if (Array.isArray(readStoreResult.result)) {\n      return this.combineExecResults(\n        readStoreResult,\n        this.executeSubSelectedArray({\n          field,\n          array: readStoreResult.result,\n          execContext,\n        }),\n      );\n    }\n\n    // Handle all scalar types here\n    if (!field.selectionSet) {\n      assertSelectionSetForIdValue(field, readStoreResult.result);\n      if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n        maybeDeepFreeze(readStoreResult);\n      }\n      return readStoreResult;\n    }\n\n    // From here down, the field has a selection set, which means it's trying to\n    // query a GraphQLObjectType\n    if (readStoreResult.result == null) {\n      // Basically any field in a GraphQL response can be null, or missing\n      return readStoreResult;\n    }\n\n    // Returned value is an object, and the query has a sub-selection. Recurse.\n    return this.combineExecResults(\n      readStoreResult,\n      this.executeSelectionSet({\n        selectionSet: field.selectionSet,\n        rootValue: readStoreResult.result,\n        execContext,\n      }),\n    );\n  }\n\n  private combineExecResults<T>(\n    ...execResults: ExecResult<T>[]\n  ): ExecResult<T> {\n    let missing: ExecResultMissingField[] | undefined;\n    execResults.forEach(execResult => {\n      if (execResult.missing) {\n        missing = missing || [];\n        missing.push(...execResult.missing);\n      }\n    });\n    return {\n      result: execResults.pop()!.result,\n      missing,\n    };\n  }\n\n  private executeSubSelectedArray({\n    field,\n    array,\n    execContext,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: ExecResultMissingField[] | undefined;\n\n    function handleMissing<T>(childResult: ExecResult<T>): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      return childResult.result;\n    }\n\n    array = array.map(item => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          execContext,\n        }));\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          rootValue: item,\n          execContext,\n        }));\n      }\n\n      assertSelectionSetForIdValue(field, item);\n\n      return item;\n    });\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n\n    return { result: array, missing };\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  field: FieldNode,\n  value: any,\n) {\n  if (!field.selectionSet && isIdValue(value)) {\n    throw new InvariantError(\n      `Missing selection set for object of type ${\n        value.typename\n      } returned for query field ${field.name.value}`\n    );\n  }\n}\n\nfunction defaultFragmentMatcher() {\n  return true;\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  invariant(isIdValue(idValue), `\\\nEncountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n}\n\nfunction readStoreResolver(\n  object: StoreObject,\n  typename: string | void,\n  fieldName: string,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n): ExecResult<StoreValue> {\n  let storeKeyName = fieldName;\n  if (args || directives) {\n    // We happen to know here that getStoreKeyName returns its first\n    // argument unmodified if there are no args or directives, so we can\n    // avoid calling the function at all in that case, as a small but\n    // important optimization to this frequently executed code.\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n\n  let fieldValue: StoreValue | void = void 0;\n\n  if (object) {\n    fieldValue = object[storeKeyName];\n\n    if (\n      typeof fieldValue === 'undefined' &&\n      context.cacheRedirects &&\n      typeof typename === 'string'\n    ) {\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(object, args, {\n            getCacheKey(storeObj: StoreObject) {\n              const id = context.dataIdFromObject!(storeObj);\n              return id && toIdValue({\n                id,\n                typename: storeObj.__typename,\n              });\n            },\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    return {\n      result: fieldValue,\n      missing: [{\n        object,\n        fieldName: storeKeyName,\n        tolerable: false,\n      }],\n    };\n  }\n\n  if (isJsonValue(fieldValue)) {\n    fieldValue = fieldValue.json;\n  }\n\n  return {\n    result: fieldValue,\n  };\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(protected data: NormalizedCacheObject = Object.create(null)) {}\n\n  public toObject() {\n    return this.data;\n  }\n\n  public get(dataId: string) {\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n\n  public delete(dataId: string) {\n    this.data[dataId] = void 0;\n  }\n\n  public clear() {\n    this.data = Object.create(null);\n  }\n\n  public replace(newData: NormalizedCacheObject) {\n    this.data = newData || Object.create(null);\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n","import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { FragmentMatcher } from './readFromStore';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  StoreValue,\n  toIdValue,\n  isEqual,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport { ObjectCache } from './objectCache';\nimport { defaultNormalizedCacheFactory } from './depTrackingCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${JSON.stringify(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\nexport type WriteContext = {\n  readonly store: NormalizedCache;\n  readonly processedData?: { [x: string]: FieldNode[] };\n  readonly variables?: any;\n  readonly dataIdFromObject?: IdGetter;\n  readonly fragmentMap?: FragmentMap;\n  readonly fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport class StoreWriter {\n  /**\n   * Writes the result of a query to the store.\n   *\n   * @param result The result object returned for the query document.\n   *\n   * @param query The query document whose result we are writing to the store.\n   *\n   * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n   *\n   * @param variables A map from the name of a variable to its value. These variables can be\n   * referenced by the query document.\n   *\n   * @param dataIdFromObject A function that returns an object identifier given a particular result\n   * object. See the store documentation for details and an example of this function.\n   *\n   * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n   */\n  public writeQueryToStore({\n    query,\n    result,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    query: DocumentNode;\n    result: Object;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    return this.writeResultToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      document: query,\n      store,\n      variables,\n      dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n  }\n\n  public writeResultToStore({\n    dataId,\n    result,\n    document,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    dataId: string;\n    result: any;\n    document: DocumentNode;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n    const operationDefinition = getOperationDefinition(document)!;\n\n    try {\n      return this.writeSelectionSetToStore({\n        result,\n        dataId,\n        selectionSet: operationDefinition.selectionSet,\n        context: {\n          store,\n          processedData: {},\n          variables: assign(\n            {},\n            getDefaultValues(operationDefinition),\n            variables,\n          ),\n          dataIdFromObject,\n          fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n          fragmentMatcherFunction,\n        },\n      });\n    } catch (e) {\n      throw enhanceErrorWithDocument(e, document);\n    }\n  }\n\n  public writeSelectionSetToStore({\n    result,\n    dataId,\n    selectionSet,\n    context,\n  }: {\n    dataId: string;\n    result: any;\n    selectionSet: SelectionSetNode;\n    context: WriteContext;\n  }): NormalizedCache {\n    const { variables, store, fragmentMap } = context;\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        return;\n      }\n\n      if (isField(selection)) {\n        const resultFieldKey: string = resultKeyNameFromField(selection);\n        const value: any = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          this.writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          let isDefered = false;\n          let isClient = false;\n          if (selection.directives && selection.directives.length) {\n            // If this is a defered field we don't need to throw / warn.\n            isDefered = selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n            // When using the @client directive, it might be desirable in\n            // some cases to want to write a selection set to the store,\n            // without having all of the selection set values available.\n            // This is because the @client field values might have already\n            // been written to the cache separately (e.g. via Apollo\n            // Cache's `writeData` capabilities). Because of this, we'll\n            // skip the missing field warning for fields with @client\n            // directives.\n            isClient = selection.directives.some(\n              directive => directive.name && directive.name.value === 'client',\n            );\n          }\n\n          if (!isDefered && !isClient && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            invariant.warn(\n              `Missing field ${resultFieldKey} in ${JSON.stringify(\n                result,\n                null,\n                2,\n              ).substring(0, 100)}`,\n            );\n          }\n        }\n      } else {\n        // This is not a field, so it must be a fragment, either inline or named\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // Named fragment\n          fragment = (fragmentMap || {})[selection.name.value];\n          invariant(fragment, `No fragment named ${selection.name.value}.`);\n        }\n\n        let matches = true;\n        if (context.fragmentMatcherFunction && fragment.typeCondition) {\n          // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n          // Right now we have to pretend that we're passing in an idValue and that there's a store\n          // on the context.\n          const id = dataId || 'self';\n          const idValue = toIdValue({ id, typename: undefined });\n          const fakeContext: ReadStoreContext = {\n            // NOTE: fakeContext always uses ObjectCache\n            // since this is only to ensure the return value of 'matches'\n            store: new ObjectCache({ [id]: result }),\n            cacheRedirects: {},\n          };\n          const match = context.fragmentMatcherFunction(\n            idValue,\n            fragment.typeCondition.name.value,\n            fakeContext,\n          );\n          if (!isProduction() && match === 'heuristic') {\n            invariant.error('WARNING: heuristic fragment matching going on!');\n          }\n          matches = !!match;\n        }\n\n        if (matches) {\n          this.writeSelectionSetToStore({\n            result,\n            selectionSet: fragment.selectionSet,\n            dataId,\n            context,\n          });\n        }\n      }\n    });\n\n    return store;\n  }\n\n  private writeFieldToStore({\n    field,\n    value,\n    dataId,\n    context,\n  }: {\n    field: FieldNode;\n    value: any;\n    dataId: string;\n    context: WriteContext;\n  }) {\n    const { variables, dataIdFromObject, store } = context;\n\n    let storeValue: StoreValue;\n    let storeObject: StoreObject;\n\n    const storeFieldName: string = storeKeyNameFromField(field, variables);\n\n    // If this is a scalar value...\n    if (!field.selectionSet || value === null) {\n      storeValue =\n        value != null && typeof value === 'object'\n          ? // If the scalar value is a JSON blob, we have to \"escape\" it so it cant pretend to be\n            // an id.\n            { type: 'json', json: value }\n          : // Otherwise, just store the scalar directly in the store.\n            value;\n    } else if (Array.isArray(value)) {\n      const generatedId = `${dataId}.${storeFieldName}`;\n\n      storeValue = this.processArrayValue(\n        value,\n        generatedId,\n        field.selectionSet,\n        context,\n      );\n    } else {\n      // It's an object\n      let valueDataId = `${dataId}.${storeFieldName}`;\n      let generated = true;\n\n      // We only prepend the '$' if the valueDataId isn't already a generated\n      // id.\n      if (!isGeneratedId(valueDataId)) {\n        valueDataId = '$' + valueDataId;\n      }\n\n      if (dataIdFromObject) {\n        const semanticId = dataIdFromObject(value);\n\n        // We throw an error if the first character of the id is '$. This is\n        // because we use that character to designate an Apollo-generated id\n        // and we use the distinction between user-desiginated and application-provided\n        // ids when managing overwrites.\n        invariant(\n          !semanticId || !isGeneratedId(semanticId),\n          'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n        );\n\n        if (\n          semanticId ||\n          (typeof semanticId === 'number' && semanticId === 0)\n        ) {\n          valueDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(valueDataId, field, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: valueDataId,\n          result: value,\n          selectionSet: field.selectionSet,\n          context,\n        });\n      }\n\n      // We take the id and escape it (i.e. wrap it with an enclosing object).\n      // This allows us to distinguish IDs from normal scalars.\n      const typename = value.__typename;\n      storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n      // check if there was a generated id at the location where we're\n      // about to place this new id. If there was, we have to merge the\n      // data from that id with the data we're about to write in the store.\n      storeObject = store.get(dataId);\n      const escapedId =\n        storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n      if (escapedId !== storeValue && isIdValue(escapedId)) {\n        const hadTypename = escapedId.typename !== undefined;\n        const hasTypename = typename !== undefined;\n        const typenameChanged =\n          hadTypename && hasTypename && escapedId.typename !== typename;\n\n        // If there is already a real id in the store and the current id we\n        // are dealing with is generated, we throw an error.\n        // One exception we allow is when the typename has changed, which occurs\n        // when schema defines a union, both with and without an ID in the same place.\n        // checks if we \"lost\" the read id\n        invariant(\n          !generated || escapedId.generated || typenameChanged,\n          `Store error: the application attempted to write an object with no provided id but the store already contains an id of ${\n            escapedId.id\n          } for this object. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        // checks if we \"lost\" the typename\n        invariant(\n          !hadTypename || hasTypename,\n          `Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of ${\n            escapedId.typename\n          } for the object of id ${escapedId.id}. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        if (escapedId.generated) {\n          // We should only merge if it's an object of the same type,\n          // otherwise we should delete the generated object\n          if (typenameChanged) {\n            // Only delete the generated object when the old object was\n            // inlined, and the new object is not. This is indicated by\n            // the old id being generated, and the new id being real.\n            if (!generated) {\n              store.delete(escapedId.id);\n            }\n          } else {\n            mergeWithGenerated(escapedId.id, (storeValue as IdValue).id, store);\n          }\n        }\n      }\n    }\n\n    storeObject = store.get(dataId);\n    if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n      store.set(dataId, {\n        ...storeObject,\n        [storeFieldName]: storeValue,\n      });\n    }\n  }\n\n  private processArrayValue(\n    value: any[],\n    generatedId: string,\n    selectionSet: SelectionSetNode,\n    context: WriteContext,\n  ): any[] {\n    return value.map((item: any, index: any) => {\n      if (item === null) {\n        return null;\n      }\n\n      let itemDataId = `${generatedId}.${index}`;\n\n      if (Array.isArray(item)) {\n        return this.processArrayValue(item, itemDataId, selectionSet, context);\n      }\n\n      let generated = true;\n\n      if (context.dataIdFromObject) {\n        const semanticId = context.dataIdFromObject(item);\n\n        if (semanticId) {\n          itemDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: itemDataId,\n          result: item,\n          selectionSet,\n          context,\n        });\n      }\n\n      return toIdValue(\n        { id: itemDataId, typename: item.__typename },\n        generated,\n      );\n    });\n  }\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n): boolean {\n  if (generatedKey === realKey) {\n    return false;\n  }\n\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n  let madeChanges = false;\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n\n    if (\n      isIdValue(value) &&\n      isGeneratedId(value.id) &&\n      isIdValue(realValue) &&\n      !isEqual(value, realValue) &&\n      mergeWithGenerated(value.id, realValue.id, cache)\n    ) {\n      madeChanges = true;\n    }\n  });\n\n  cache.delete(generatedKey);\n  const newRealValue = { ...generated, ...real };\n\n  if (isEqual(newRealValue, real)) {\n    return madeChanges;\n  }\n\n  cache.set(realKey, newRealValue);\n  return true;\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n","// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\n\nimport { Cache, ApolloCache, Transaction } from 'apollo-cache';\n\nimport { addTypenameToDocument, canUseWeakMap } from 'apollo-utilities';\n\nimport { wrap } from 'optimism';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\n\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { KeyTrie } from 'optimism';\nimport { ObjectCache } from './objectCache';\n\nexport interface InMemoryCacheConfig extends ApolloReducerConfig {\n  resultCaching?: boolean;\n  freezeResults?: boolean;\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  freezeResults: false,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class OptimisticCacheLayer extends ObjectCache {\n  constructor(\n    public readonly optimisticId: string,\n    // OptimisticCacheLayer objects always wrap some other parent cache, so\n    // this.parent should never be null.\n    public readonly parent: NormalizedCache,\n    public readonly transaction: Transaction<NormalizedCacheObject>,\n  ) {\n    super(Object.create(null));\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  // All the other accessor methods of ObjectCache work without knowing about\n  // this.parent, but the get method needs to be overridden to implement the\n  // fallback this.parent.get(dataId) behavior.\n  public get(dataId: string) {\n    return hasOwn.call(this.data, dataId)\n      ? this.data[dataId]\n      : this.parent.get(dataId);\n  }\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: NormalizedCache;\n  private optimisticData: NormalizedCache;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n  private cacheKeyRoot = new KeyTrie<object>(canUseWeakMap);\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      invariant.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      invariant.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = !!this.config.addTypename;\n\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    this.data = this.config.resultCaching\n      ? new DepTrackingCache()\n      : new ObjectCache();\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of OptimisticCacheLayer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = this.data;\n\n    this.storeWriter = new StoreWriter();\n    this.storeReader = new StoreReader({\n      cacheKeyRoot: this.cacheKeyRoot,\n      freezeResults: config.freezeResults,\n    });\n\n    const cache = this;\n    const { maybeBroadcastWatch } = cache;\n    this.maybeBroadcastWatch = wrap((c: Cache.WatchOptions) => {\n      return maybeBroadcastWatch.call(this, c);\n    }, {\n      makeCacheKey(c: Cache.WatchOptions) {\n        if (c.optimistic) {\n          // If we're reading optimistic data, it doesn't matter if this.data\n          // is a DepTrackingCache, since it will be ignored.\n          return;\n        }\n\n        if (c.previousResult) {\n          // If a previousResult was provided, assume the caller would prefer\n          // to compare the previous data to the new data to determine whether\n          // to broadcast, so we should disable caching by returning here, to\n          // give maybeBroadcastWatch a chance to do that comparison.\n          return;\n        }\n\n        if (cache.data instanceof DepTrackingCache) {\n          // Return a cache key (thus enabling caching) only if we're currently\n          // using a data store that can track cache dependencies.\n          return cache.cacheKeyRoot.lookup(\n            c.query,\n            JSON.stringify(c.variables),\n          );\n        }\n      }\n    });\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).toObject();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    if (typeof options.rootId === 'string' &&\n        typeof this.data.get(options.rootId) === 'undefined') {\n      return null;\n    }\n\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.readQueryFromStore({\n      store: options.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n      rootId: options.rootId,\n      fragmentMatcherFunction,\n      previousResult: options.previousResult,\n      config: this.config,\n    }) || null;\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    this.storeWriter.writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.diffQueryAgainstStore({\n      store: query.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.add(watch);\n\n    return () => {\n      this.watches.delete(watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new InvariantError(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const toReapply: OptimisticCacheLayer[] = [];\n    let removedCount = 0;\n    let layer = this.optimisticData;\n\n    while (layer instanceof OptimisticCacheLayer) {\n      if (layer.optimisticId === idToRemove) {\n        ++removedCount;\n      } else {\n        toReapply.push(layer);\n      }\n      layer = layer.parent;\n    }\n\n    if (removedCount > 0) {\n      // Reset this.optimisticData to the first non-OptimisticCacheLayer object,\n      // which is almost certainly this.data.\n      this.optimisticData = layer;\n\n      // Reapply the layers whose optimistic IDs do not match the removed ID.\n      while (toReapply.length > 0) {\n        const layer = toReapply.pop()!;\n        this.performTransaction(layer.transaction, layer.optimisticId);\n      }\n\n      this.broadcastWatches();\n    }\n  }\n\n  public performTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    // This parameter is not part of the performTransaction signature inherited\n    // from the ApolloCache abstract class, but it's useful because it saves us\n    // from duplicating this implementation in recordOptimisticTransaction.\n    optimisticId?: string,\n  ) {\n    const { data, silenceBroadcast } = this;\n    this.silenceBroadcast = true;\n\n    if (typeof optimisticId === 'string') {\n      // Add a new optimistic layer and temporarily make this.data refer to\n      // that layer for the duration of the transaction.\n      this.data = this.optimisticData = new OptimisticCacheLayer(\n        // Note that there can be multiple layers with the same optimisticId.\n        // When removeOptimistic(id) is called for that id, all matching layers\n        // will be removed, and the remaining layers will be reapplied.\n        optimisticId,\n        this.optimisticData,\n        transaction,\n      );\n    }\n\n    try {\n      transaction(this);\n    } finally {\n      this.silenceBroadcast = silenceBroadcast;\n      this.data = data;\n    }\n\n    // This broadcast does nothing if this.silenceBroadcast is true.\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    return this.performTransaction(transaction, id);\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        // If someone calls transformDocument and then mistakenly passes the\n        // result back into an API that also calls transformDocument, make sure\n        // we don't keep creating new query documents.\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  }\n\n  protected broadcastWatches() {\n    if (!this.silenceBroadcast) {\n      this.watches.forEach(c => this.maybeBroadcastWatch(c));\n    }\n  }\n\n  // This method is wrapped in the constructor so that it will be called only\n  // if the data that would be broadcast has changed.\n  private maybeBroadcastWatch(c: Cache.WatchOptions) {\n    c.callback(\n      this.diff({\n        query: c.query,\n        variables: c.variables,\n        previousResult: c.previousResult && c.previousResult(),\n        optimistic: c.optimistic,\n      }),\n    );\n  }\n}\n","/* tslint:disable */\n\nimport { ApolloLink, Observable, RequestHandler, fromError } from 'apollo-link';\nimport {\n  serializeFetchParameter,\n  selectURI,\n  parseAndCheckHttpResponse,\n  checkFetcher,\n  selectHttpOptionsAndBody,\n  createSignalIfSupported,\n  fallbackHttpConfig,\n  Body,\n  HttpOptions,\n  UriFunction as _UriFunction,\n} from 'apollo-link-http-common';\nimport { DefinitionNode } from 'graphql';\n\nexport namespace HttpLink {\n  //TODO Would much rather be able to export directly\n  export interface UriFunction extends _UriFunction {}\n  export interface Options extends HttpOptions {\n    /**\n     * If set to true, use the HTTP GET method for query operations. Mutations\n     * will still use the method specified in fetchOptions.method (which defaults\n     * to POST).\n     */\n    useGETForQueries?: boolean;\n  }\n}\n\n// For backwards compatibility.\nexport import FetchOptions = HttpLink.Options;\nexport import UriFunction = HttpLink.UriFunction;\n\nexport const createHttpLink = (linkOptions: HttpLink.Options = {}) => {\n  let {\n    uri = '/graphql',\n    // use default global fetch if nothing passed in\n    fetch: fetcher,\n    includeExtensions,\n    useGETForQueries,\n    ...requestOptions\n  } = linkOptions;\n\n  // dev warnings to ensure fetch is present\n  checkFetcher(fetcher);\n\n  //fetcher is set here rather than the destructuring to ensure fetch is\n  //declared before referencing it. Reference in the destructuring would cause\n  //a ReferenceError\n  if (!fetcher) {\n    fetcher = fetch;\n  }\n\n  const linkConfig = {\n    http: { includeExtensions },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink(operation => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    const clientAwarenessHeaders = {};\n    if (context.clientAwareness) {\n      const { name, version } = context.clientAwareness;\n      if (name) {\n        clientAwarenessHeaders['apollographql-client-name'] = name;\n      }\n      if (version) {\n        clientAwarenessHeaders['apollographql-client-version'] = version;\n      }\n    }\n\n    const contextHeaders = { ...clientAwarenessHeaders, ...context.headers };\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders,\n    };\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBody(\n      operation,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig,\n    );\n\n    let controller;\n    if (!(options as any).signal) {\n      const { controller: _controller, signal } = createSignalIfSupported();\n      controller = _controller;\n      if (controller) (options as any).signal = signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === 'OperationDefinition' && d.operation === 'mutation';\n    };\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = 'GET';\n    }\n\n    if (options.method === 'GET') {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, 'Payload');\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable(observer => {\n      fetcher(chosenURI, options)\n        .then(response => {\n          operation.setContext({ response });\n          return response;\n        })\n        .then(parseAndCheckHttpResponse(operation))\n        .then(result => {\n          // we have data and can send it to back up the link chain\n          observer.next(result);\n          observer.complete();\n          return result;\n        })\n        .catch(err => {\n          // fetch was cancelled so it's already been cleaned up in the unsubscribe\n          if (err.name === 'AbortError') return;\n          // if it is a network error, BUT there is graphql result info\n          // fire the next observer before calling error\n          // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`\n          // to pass to UI\n          // this should only happen if we *also* have data as part of the response key per\n          // the spec\n          if (err.result && err.result.errors && err.result.data) {\n            // if we don't call next, the UI can only show networkError because AC didn't\n            // get any graphqlErrors\n            // this is graphql execution result info (i.e errors and possibly data)\n            // this is because there is no formal spec how errors should translate to\n            // http status codes. So an auth error (401) could have both data\n            // from a public field, errors from a private field, and a status of 401\n            // {\n            //  user { // this will have errors\n            //    firstName\n            //  }\n            //  products { // this is public so will have data\n            //    cost\n            //  }\n            // }\n            //\n            // the result of above *could* look like this:\n            // {\n            //   data: { products: [{ cost: \"$10\" }] },\n            //   errors: [{\n            //      message: 'your session has timed out',\n            //      path: []\n            //   }]\n            // }\n            // status code of above would be a 401\n            // in the UI you want to show data where you can, errors as data where you can\n            // and use correct http status codes\n            observer.next(err.result);\n          }\n          observer.error(err);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nfunction rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if ('query' in body) {\n    addQueryParam('query', body.query);\n  }\n  if (body.operationName) {\n    addQueryParam('operationName', body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        'Variables map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('variables', serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        'Extensions map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('extensions', serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = '',\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf('#');\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join('&') + fragment;\n  return { newURI };\n}\n\nexport class HttpLink extends ApolloLink {\n  public requester: RequestHandler;\n  constructor(opts?: HttpLink.Options) {\n    super(createHttpLink(opts).request);\n  }\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { ApolloError } from 'apollo-client';\nimport React from 'react';\nimport { useApolloClient } from './ApolloContext';\nimport actHack from './internal/actHack';\nimport { objToKey } from './utils';\n\nvar getInitialState = function getInitialState() {\n  return {\n    called: false,\n    data: undefined,\n    error: undefined,\n    hasError: false,\n    loading: false\n  };\n};\n\nexport function useMutation(mutation, baseOptions) {\n  if (baseOptions === void 0) {\n    baseOptions = {};\n  }\n\n  var client = useApolloClient(baseOptions.client);\n\n  var _React$useState = React.useState(getInitialState),\n      result = _React$useState[0],\n      setResult = _React$useState[1];\n\n  var _baseOptions = baseOptions,\n      _baseOptions$rethrow = _baseOptions.rethrow,\n      rethrow = _baseOptions$rethrow === void 0 ? true : _baseOptions$rethrow,\n      options = _objectWithoutPropertiesLoose(_baseOptions, [\"rethrow\"]);\n\n  var mergeResult = function mergeResult(partialResult) {\n    // A hack to get rid React warnings during tests.\n    actHack(function () {\n      setResult(function (prev) {\n        return _extends({}, prev, {}, partialResult);\n      });\n    });\n  }; // reset state if client instance changes\n\n\n  React.useEffect(function () {\n    mergeResult(getInitialState());\n  }, [client]);\n\n  var _useMutationTracking = useMutationTracking(),\n      generateNewMutationId = _useMutationTracking.generateNewMutationId,\n      isMostRecentMutation = _useMutationTracking.isMostRecentMutation;\n\n  var onMutationStart = function onMutationStart() {\n    if (!result.loading) {\n      mergeResult({\n        called: true,\n        data: undefined,\n        error: undefined,\n        hasError: false,\n        loading: true\n      });\n    }\n  };\n\n  var onMutationError = function onMutationError(error, mutationId) {\n    if (isMostRecentMutation(mutationId)) {\n      mergeResult({\n        error: error,\n        hasError: true,\n        loading: false\n      });\n    }\n  };\n\n  var onMutationCompleted = function onMutationCompleted(response, mutationId) {\n    var data = response.data,\n        errors = response.errors;\n\n    if (errors && errors.length > 0) {\n      onMutationError(new ApolloError({\n        graphQLErrors: errors\n      }), mutationId);\n      return;\n    }\n\n    if (isMostRecentMutation(mutationId)) {\n      mergeResult({\n        data: data,\n        loading: false\n      });\n    }\n  };\n\n  var runMutation = React.useCallback(function (mutateOptions) {\n    if (mutateOptions === void 0) {\n      mutateOptions = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      onMutationStart();\n      var mutationId = generateNewMutationId(); // merge together variables from baseOptions (if specified)\n      // and the execution\n\n      var mutateVariables = options.variables ? _extends({}, mutateOptions.variables, {}, options.variables) : mutateOptions.variables;\n      client.mutate(_extends({\n        mutation: mutation\n      }, options, {}, mutateOptions, {\n        variables: mutateVariables\n      })).then(function (response) {\n        onMutationCompleted(response, mutationId);\n        resolve(response);\n      })[\"catch\"](function (err) {\n        onMutationError(err, mutationId);\n\n        if (rethrow) {\n          reject(err);\n          return;\n        }\n\n        resolve({});\n      });\n    });\n  }, [client, mutation, objToKey(baseOptions)]);\n  return [runMutation, result];\n}\n\nfunction useMutationTracking() {\n  var mostRecentMutationId = React.useRef(0);\n\n  var generateNewMutationId = function generateNewMutationId() {\n    mostRecentMutationId.current += 1;\n    return mostRecentMutationId.current;\n  };\n\n  var isMostRecentMutation = function isMostRecentMutation(mutationId) {\n    return mostRecentMutationId.current === mutationId;\n  };\n\n  return {\n    generateNewMutationId: generateNewMutationId,\n    isMostRecentMutation: isMostRecentMutation\n  };\n}","import { createContext } from 'react';\nexport function createSSRManager() {\n  var promiseSet = new Set();\n  return {\n    hasPromises: function hasPromises() {\n      return promiseSet.size > 0;\n    },\n    register: function register(promise) {\n      promiseSet.add(promise);\n    },\n    consumeAndAwaitPromises: function consumeAndAwaitPromises() {\n      var promises = Array.from(promiseSet);\n      promiseSet.clear();\n      return Promise.all(promises);\n    }\n  };\n}\nexport var SSRContext = createContext(null);","function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { print } from 'graphql/language/printer';\nimport { objToKey } from './utils';\nvar cachedQueriesByClient = new WeakMap();\nexport function getCachedObservableQuery(client, options) {\n  var queriesForClient = getCachedQueriesForClient(client);\n  var cacheKey = getCacheKey(options);\n  var observableQuery = queriesForClient.get(cacheKey);\n\n  if (observableQuery == null) {\n    observableQuery = client.watchQuery(options);\n    queriesForClient.set(cacheKey, observableQuery);\n  }\n\n  return observableQuery;\n}\nexport function invalidateCachedObservableQuery(client, options) {\n  var queriesForClient = getCachedQueriesForClient(client);\n  var cacheKey = getCacheKey(options);\n  queriesForClient[\"delete\"](cacheKey);\n}\n\nfunction getCachedQueriesForClient(client) {\n  var queriesForClient = cachedQueriesByClient.get(client);\n\n  if (queriesForClient == null) {\n    queriesForClient = new Map();\n    cachedQueriesByClient.set(client, queriesForClient);\n  }\n\n  return queriesForClient;\n}\n\nfunction getCacheKey(_ref) {\n  var query = _ref.query,\n      options = _objectWithoutPropertiesLoose(_ref, [\"query\"]);\n\n  return print(query) + \"@@\" + objToKey(options);\n}","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { ApolloError } from 'apollo-client';\nimport { useContext, useEffect, useMemo, useState } from 'react';\nimport { useApolloClient } from './ApolloContext';\nimport { SSRContext } from './internal/SSRContext';\nimport actHack from './internal/actHack';\nimport { getCachedObservableQuery, invalidateCachedObservableQuery } from './queryCache';\nimport { compact, objToKey } from './utils';\nexport function useQuery(query, _temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$ssr = _ref.ssr,\n      ssr = _ref$ssr === void 0 ? true : _ref$ssr,\n      _ref$skip = _ref.skip,\n      skip = _ref$skip === void 0 ? false : _ref$skip,\n      _ref$suspend = _ref.suspend,\n      suspend = _ref$suspend === void 0 ? false : _ref$suspend,\n      pollInterval = _ref.pollInterval,\n      _ref$notifyOnNetworkS = _ref.notifyOnNetworkStatusChange,\n      notifyOnNetworkStatusChange = _ref$notifyOnNetworkS === void 0 ? false : _ref$notifyOnNetworkS,\n      overrideClient = _ref.client,\n      context = _ref.context,\n      metadata = _ref.metadata,\n      variables = _ref.variables,\n      actualCachePolicy = _ref.fetchPolicy,\n      errorPolicy = _ref.errorPolicy,\n      fetchResults = _ref.fetchResults;\n\n  var client = useApolloClient(overrideClient);\n  var ssrManager = useContext(SSRContext);\n  var ssrInUse = ssr && ssrManager; // Skips when `skip: true` or SSRContext passed but `ssr: false`\n\n  var shouldSkip = skip || ssrManager != null && !ssr;\n  var fetchPolicy = ssrInUse && ( // Taken from https://github.com/apollographql/react-apollo/blob/2d7e48b7d0c26e792e1ed26e98bb84d8fba5bb8a/src/Query.tsx#L167-L169\n  actualCachePolicy === 'network-only' || actualCachePolicy === 'cache-and-network') ? 'cache-first' : actualCachePolicy;\n  var watchQueryOptions = useMemo(function () {\n    return compact({\n      context: context,\n      errorPolicy: errorPolicy,\n      fetchPolicy: fetchPolicy,\n      fetchResults: fetchResults,\n      metadata: metadata,\n      notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n      pollInterval: pollInterval,\n      query: query,\n      variables: variables\n    });\n  }, [query, pollInterval, notifyOnNetworkStatusChange, context && objToKey(context), metadata && objToKey(metadata), variables && objToKey(variables), fetchPolicy, errorPolicy, fetchResults]);\n  var observableQuery = useMemo(function () {\n    return getCachedObservableQuery(client, watchQueryOptions);\n  }, [client, watchQueryOptions]);\n\n  var _useState = useState(0),\n      responseId = _useState[0],\n      setResponseId = _useState[1];\n\n  var currentResult = useMemo(function () {\n    var helpers = {\n      fetchMore: observableQuery.fetchMore.bind(observableQuery),\n      refetch: observableQuery.refetch.bind(observableQuery),\n      startPolling: observableQuery.startPolling.bind(observableQuery),\n      stopPolling: observableQuery.stopPolling.bind(observableQuery),\n      updateQuery: observableQuery.updateQuery.bind(observableQuery)\n    };\n    var result = observableQuery.getCurrentResult(); // return the old result data when there is an error\n\n    var data = result.data;\n\n    if (result.error || result.errors) {\n      data = _extends({}, result.data, {}, (observableQuery.getLastResult() || {}).data);\n    }\n\n    if (shouldSkip) {\n      // Taken from https://github.com/apollographql/react-apollo/blob/5cb63b3625ce5e4a3d3e4ba132eaec2a38ef5d90/src/Query.tsx#L376-L381\n      return _extends({}, helpers, {\n        data: undefined,\n        error: undefined,\n        loading: false,\n        networkStatus: undefined\n      });\n    }\n\n    return _extends({}, helpers, {\n      data: data,\n      error: result.errors && result.errors.length > 0 ? new ApolloError({\n        graphQLErrors: result.errors\n      }) : result.error,\n      errors: result.errors,\n      loading: result.loading,\n      // don't try to return `networkStatus` when suspense it's used\n      // because it's unreliable in that case\n      // https://github.com/trojanowski/react-apollo-hooks/pull/68\n      networkStatus: suspend ? undefined : result.networkStatus,\n      partial: result.partial,\n      stale: result.stale\n    });\n  }, [shouldSkip, responseId, observableQuery]);\n  useEffect(function () {\n    if (shouldSkip) {\n      return;\n    }\n\n    var invalidateCurrentResult = function invalidateCurrentResult() {\n      // A hack to get rid React warnings during tests. The default\n      // implementation of `actHack` just invokes the callback immediately.\n      // In tests, it's replaced with `act` from react-testing-library.\n      // A better solution welcome.\n      actHack(function () {\n        setResponseId(function (x) {\n          return x + 1;\n        });\n      });\n    };\n\n    var subscription = observableQuery.subscribe(invalidateCurrentResult, invalidateCurrentResult);\n    invalidateCachedObservableQuery(client, watchQueryOptions);\n    return function () {\n      subscription.unsubscribe();\n    };\n  }, [shouldSkip, observableQuery]);\n  ensureSupportedFetchPolicy(suspend, fetchPolicy);\n\n  if (currentResult.partial) {\n    if (suspend) {\n      // throw a promise - use the react suspense to wait until the data is\n      // available\n      throw observableQuery.result();\n    }\n\n    if (ssrInUse) {\n      ssrManager.register(observableQuery.result());\n    }\n  }\n\n  return currentResult;\n}\n\nfunction ensureSupportedFetchPolicy(suspend, fetchPolicy) {\n  if (suspend && fetchPolicy && fetchPolicy !== 'cache-first') {\n    throw new Error(\"Fetch policy \" + fetchPolicy + \" is not supported without 'suspend: false'\");\n  }\n}","import { ApolloClient } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport { invariant } from 'ts-invariant';\nimport {\n  ApolloContextValue,\n  parser,\n  DocumentType,\n  operationName\n} from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { CommonOptions } from '../types';\n\nexport abstract class OperationData<TOptions = any> {\n  public isMounted: boolean = false;\n  public previousOptions: CommonOptions<TOptions> = {} as CommonOptions<\n    TOptions\n  >;\n  public context: ApolloContextValue = {};\n  public client: ApolloClient<object> | undefined;\n\n  private options: CommonOptions<TOptions> = {} as CommonOptions<TOptions>;\n\n  constructor(options?: CommonOptions<TOptions>, context?: ApolloContextValue) {\n    this.options = options || ({} as CommonOptions<TOptions>);\n    this.context = context || {};\n  }\n\n  public getOptions(): CommonOptions<TOptions> {\n    return this.options;\n  }\n\n  public setOptions(\n    newOptions: CommonOptions<TOptions>,\n    storePrevious: boolean = false\n  ) {\n    if (storePrevious && !isEqual(this.options, newOptions)) {\n      this.previousOptions = this.options;\n    }\n    this.options = newOptions;\n  }\n\n  public abstract execute(...args: any): any;\n  public abstract afterExecute(...args: any): void | (() => void);\n  public abstract cleanup(): void;\n\n  protected unmount() {\n    this.isMounted = false;\n  }\n\n  protected refreshClient() {\n    const client =\n      (this.options && this.options.client) ||\n      (this.context && this.context.client);\n\n    invariant(\n      !!client,\n      'Could not find \"client\" in the context or passed in as an option. ' +\n        'Wrap the root component in an <ApolloProvider>, or pass an ' +\n        'ApolloClient instance in via options.'\n    );\n\n    let isNew = false;\n    if (client !== this.client) {\n      isNew = true;\n      this.client = client;\n      this.cleanup();\n    }\n    return {\n      client: this.client as ApolloClient<object>,\n      isNew\n    };\n  }\n\n  protected verifyDocumentType(document: DocumentNode, type: DocumentType) {\n    const operation = parser(document);\n    const requiredOperationName = operationName(type);\n    const usedOperationName = operationName(operation.type);\n    invariant(\n      operation.type === type,\n      `Running a ${requiredOperationName} requires a graphql ` +\n        `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n    );\n  }\n}\n","import {\n  ApolloQueryResult,\n  ApolloError,\n  NetworkStatus,\n  FetchMoreOptions,\n  FetchMoreQueryOptions,\n  UpdateQueryOptions,\n  SubscribeToMoreOptions\n} from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  QueryResult,\n  ObservableQueryFields\n} from '@apollo/react-common';\n\nimport {\n  QueryPreviousData,\n  QueryOptions,\n  QueryCurrentObservable,\n  QueryTuple,\n  QueryLazyOptions\n} from '../types';\nimport { OperationData } from './OperationData';\n\nexport class QueryData<TData, TVariables> extends OperationData {\n  private previousData: QueryPreviousData<TData, TVariables> = {};\n  private currentObservable: QueryCurrentObservable<TData, TVariables> = {};\n  private forceUpdate: any;\n\n  private runLazy: boolean = false;\n  private lazyOptions?: QueryLazyOptions<TVariables>;\n\n  constructor({\n    options,\n    context,\n    forceUpdate\n  }: {\n    options: QueryOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    forceUpdate: any;\n  }) {\n    super(options, context);\n    this.forceUpdate = forceUpdate;\n  }\n\n  public execute(): QueryResult<TData, TVariables> {\n    this.refreshClient();\n\n    const { skip, query } = this.getOptions();\n    if (skip || query !== this.previousData.query) {\n      this.removeQuerySubscription();\n      this.previousData.query = query;\n    }\n\n    this.updateObservableQuery();\n\n    if (this.isMounted) this.startQuerySubscription();\n\n    return this.getExecuteSsrResult() || this.getExecuteResult();\n  }\n\n  public executeLazy(): QueryTuple<TData, TVariables> {\n    return !this.runLazy\n      ? [\n          this.runLazyQuery,\n          {\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            called: false,\n            data: undefined\n          } as QueryResult<TData, TVariables>\n        ]\n      : [this.runLazyQuery, this.execute()];\n  }\n\n  // For server-side rendering\n  public fetchData(): Promise<ApolloQueryResult<any>> | boolean {\n    const options = this.getOptions();\n    if (options.skip || options.ssr === false) return false;\n\n    // currentObservable.query is already assigned the registered SSR observable in initializeObservableQuery.\n    const obs = this.currentObservable.query!;\n    const currentResult = obs.getCurrentResult();\n    return currentResult.loading ? obs.result() : false;\n  }\n\n  public afterExecute({ lazy = false }: { lazy?: boolean } = {}) {\n    this.isMounted = true;\n\n    if (!lazy || this.runLazy) {\n      this.handleErrorOrCompleted();\n\n      // When the component is done rendering stored query errors, we'll\n      // remove those errors from the `ObservableQuery` query store, so they\n      // aren't re-displayed on subsequent (potentially error free)\n      // requests/responses.\n      setTimeout(() => {\n        this.currentObservable.query &&\n          this.currentObservable.query.resetQueryStoreErrors();\n      });\n    }\n\n    this.previousOptions = this.getOptions();\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    this.removeQuerySubscription();\n    delete this.currentObservable.query;\n    delete this.previousData.result;\n  }\n\n  public getOptions() {\n    const options = super.getOptions();\n\n    if (this.lazyOptions) {\n      options.variables = {\n        ...options.variables,\n        ...this.lazyOptions.variables\n      };\n      options.context = {\n        ...options.context,\n        ...this.lazyOptions.context\n      };\n    }\n\n    // skip is not supported when using lazy query execution.\n    if (this.runLazy) {\n      delete options.skip;\n    }\n\n    return options;\n  }\n\n  private runLazyQuery = (options?: QueryLazyOptions<TVariables>) => {\n    this.cleanup();\n\n    this.runLazy = true;\n    this.lazyOptions = options;\n    this.forceUpdate();\n  };\n\n  private getExecuteResult = (): QueryResult<TData, TVariables> => {\n    const result = this.getQueryResult();\n    this.startQuerySubscription();\n    return result;\n  };\n\n  private getExecuteSsrResult() {\n    const treeRenderingInitiated = this.context && this.context.renderPromises;\n    const ssrDisabled = this.getOptions().ssr === false;\n    const fetchDisabled = this.refreshClient().client.disableNetworkFetches;\n\n    const ssrLoading = {\n      loading: true,\n      networkStatus: NetworkStatus.loading,\n      called: true,\n      data: undefined\n    } as QueryResult<TData, TVariables>;\n\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    if (ssrDisabled && (treeRenderingInitiated || fetchDisabled)) {\n      return ssrLoading;\n    }\n\n    let result;\n    if (treeRenderingInitiated) {\n      result =\n        this.context.renderPromises!.addQueryPromise(\n          this,\n          this.getExecuteResult\n        ) || ssrLoading;\n    }\n\n    return result;\n  }\n\n  private prepareObservableQueryOptions() {\n    const options = this.getOptions();\n    this.verifyDocumentType(options.query, DocumentType.Query);\n    const displayName = options.displayName || 'Query';\n\n    // Set the fetchPolicy to cache-first for network-only and cache-and-network\n    // fetches for server side renders.\n    if (\n      this.context &&\n      this.context.renderPromises &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options.fetchPolicy = 'cache-first';\n    }\n\n    return {\n      ...options,\n      displayName,\n      context: options.context,\n      metadata: { reactComponent: { displayName } }\n    };\n  }\n\n  private initializeObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    if (this.context && this.context.renderPromises) {\n      this.currentObservable.query = this.context.renderPromises.getSSRObservable(\n        this.getOptions()\n      );\n    }\n\n    if (!this.currentObservable.query) {\n      const observableQueryOptions = this.prepareObservableQueryOptions();\n\n      this.previousData.observableQueryOptions = {\n        ...observableQueryOptions,\n        children: null\n      };\n      this.currentObservable.query = this.refreshClient().client.watchQuery({\n        ...observableQueryOptions\n      });\n\n      if (this.context && this.context.renderPromises) {\n        this.context.renderPromises.registerSSRObservable(\n          this.currentObservable.query,\n          observableQueryOptions\n        );\n      }\n    }\n  }\n\n  private updateObservableQuery() {\n    // If we skipped initially, we may not have yet created the observable\n    if (!this.currentObservable.query) {\n      this.initializeObservableQuery();\n      return;\n    }\n\n    const newObservableQueryOptions = {\n      ...this.prepareObservableQueryOptions(),\n      children: null\n    };\n\n    if (\n      !isEqual(\n        newObservableQueryOptions,\n        this.previousData.observableQueryOptions\n      )\n    ) {\n      this.previousData.observableQueryOptions = newObservableQueryOptions;\n      this.currentObservable\n        .query!.setOptions(newObservableQueryOptions)\n        // The error will be passed to the child container, so we don't\n        // need to log it here. We could conceivably log something if\n        // an option was set. OTOH we don't log errors w/ the original\n        // query. See https://github.com/apollostack/react-apollo/issues/404\n        .catch(() => {});\n    }\n  }\n\n  private startQuerySubscription() {\n    if (this.currentObservable.subscription || this.getOptions().skip) return;\n\n    const obsQuery = this.currentObservable.query!;\n    this.currentObservable.subscription = obsQuery.subscribe({\n      next: ({ loading, networkStatus, data }) => {\n        const previousResult = this.previousData.result;\n\n        // Make sure we're not attempting to re-render similar results\n        if (\n          previousResult &&\n          previousResult.loading === loading &&\n          previousResult.networkStatus === networkStatus &&\n          isEqual(previousResult.data, data)\n        ) {\n          return;\n        }\n\n        this.forceUpdate();\n      },\n      error: error => {\n        this.resubscribeToQuery();\n        if (!error.hasOwnProperty('graphQLErrors')) throw error;\n\n        const previousResult = this.previousData.result;\n        if (\n          (previousResult && previousResult.loading) ||\n          !isEqual(error, this.previousData.error)\n        ) {\n          this.previousData.error = error;\n          this.forceUpdate();\n        }\n      }\n    });\n  }\n\n  private resubscribeToQuery() {\n    this.removeQuerySubscription();\n\n    // Unfortunately, if `lastError` is set in the current\n    // `observableQuery` when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `observableQuery` before re-starting\n    // the subscription, and restore it afterwards (so the subscription\n    // has a chance to stay open).\n    const lastError = this.currentObservable.query!.getLastError();\n    const lastResult = this.currentObservable.query!.getLastResult();\n    this.currentObservable.query!.resetLastResults();\n    this.startQuerySubscription();\n    Object.assign(this.currentObservable.query!, {\n      lastError,\n      lastResult\n    });\n  }\n\n  private getQueryResult(): QueryResult<TData, TVariables> {\n    let result: any = this.observableQueryFields();\n    const options = this.getOptions();\n\n    // When skipping a query (ie. we're not querying for data but still want\n    // to render children), make sure the `data` is cleared out and\n    // `loading` is set to `false` (since we aren't loading anything).\n    if (options.skip) {\n      result = {\n        ...result,\n        data: undefined,\n        error: undefined,\n        loading: false,\n        called: true\n      };\n    } else {\n      // Fetch the current result (if any) from the store.\n      const currentResult = this.currentObservable.query!.getCurrentResult();\n      const { loading, partial, networkStatus, errors } = currentResult;\n      let { error, data } = currentResult;\n\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      if (errors && errors.length > 0) {\n        error = new ApolloError({ graphQLErrors: errors });\n      }\n\n      result = {\n        ...result,\n        loading,\n        networkStatus,\n        error,\n        called: true\n      };\n\n      if (loading) {\n        const previousData =\n          this.previousData.result && this.previousData.result.data;\n        result.data =\n          previousData && data\n            ? {\n                ...previousData,\n                ...data\n              }\n            : previousData || data;\n      } else if (error) {\n        Object.assign(result, {\n          data: (this.currentObservable.query!.getLastResult() || ({} as any))\n            .data\n        });\n      } else {\n        const { fetchPolicy } = this.currentObservable.query!.options;\n        const { partialRefetch } = options;\n        if (\n          partialRefetch &&\n          !data &&\n          partial &&\n          fetchPolicy !== 'cache-only'\n        ) {\n          // When a `Query` component is mounted, and a mutation is executed\n          // that returns the same ID as the mounted `Query`, but has less\n          // fields in its result, Apollo Client's `QueryManager` returns the\n          // data as `undefined` since a hit can't be found in the cache.\n          // This can lead to application errors when the UI elements rendered by\n          // the original `Query` component are expecting certain data values to\n          // exist, and they're all of a sudden stripped away. To help avoid\n          // this we'll attempt to refetch the `Query` data.\n          Object.assign(result, {\n            loading: true,\n            networkStatus: NetworkStatus.loading\n          });\n          result.refetch();\n          return result;\n        }\n\n        result.data = data;\n      }\n    }\n\n    result.client = this.client;\n    this.previousData.loading =\n      (this.previousData.result && this.previousData.result.loading) || false;\n    this.previousData.result = result;\n    return result;\n  }\n\n  private handleErrorOrCompleted() {\n    const obsQuery = this.currentObservable.query;\n    if (!obsQuery) return;\n\n    const { data, loading, error } = obsQuery.getCurrentResult();\n\n    if (!loading) {\n      const { query, variables, onCompleted, onError } = this.getOptions();\n\n      // No changes, so we won't call onError/onCompleted.\n      if (\n        this.previousOptions &&\n        !this.previousData.loading &&\n        isEqual(this.previousOptions.query, query) &&\n        isEqual(this.previousOptions.variables, variables)\n      ) {\n        return;\n      }\n\n      if (onCompleted && !error) {\n        onCompleted(data);\n      } else if (onError && error) {\n        onError(error);\n      }\n    }\n  }\n\n  private removeQuerySubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n\n  private obsRefetch = (variables?: TVariables) =>\n    this.currentObservable.query!.refetch(variables);\n\n  private obsFetchMore = <K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>\n  ) => this.currentObservable.query!.fetchMore(fetchMoreOptions);\n\n  private obsUpdateQuery = <TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>\n    ) => TData\n  ) => this.currentObservable.query!.updateQuery(mapFn);\n\n  private obsStartPolling = (pollInterval: number) => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.startPolling(pollInterval);\n  };\n\n  private obsStopPolling = () => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.stopPolling();\n  };\n\n  private obsSubscribeToMore = <\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >\n  ) => this.currentObservable.query!.subscribeToMore(options);\n\n  private observableQueryFields() {\n    const observable = this.currentObservable.query!;\n    return {\n      variables: observable.variables,\n      refetch: this.obsRefetch,\n      fetchMore: this.obsFetchMore,\n      updateQuery: this.obsUpdateQuery,\n      startPolling: this.obsStartPolling,\n      stopPolling: this.obsStopPolling,\n      subscribeToMore: this.obsSubscribeToMore\n    } as ObservableQueryFields<TData, TVariables>;\n  }\n}\n","import { useContext, useEffect, useReducer, useRef } from 'react';\nimport {\n  getApolloContext,\n  OperationVariables,\n  QueryResult\n} from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { QueryHookOptions, QueryOptions, QueryTuple } from '../types';\nimport { QueryData } from '../data/QueryData';\nimport { useDeepMemo } from './useDeepMemo';\n\nexport function useBaseQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode,\n  options?: QueryHookOptions<TData, TVariables>,\n  lazy = false\n) {\n  const context = useContext(getApolloContext());\n  const [tick, forceUpdate] = useReducer(x => x + 1, 0);\n  const updatedOptions = options ? { ...options, query } : { query };\n\n  const queryDataRef = useRef<QueryData<TData, TVariables>>();\n\n  if (!queryDataRef.current) {\n    queryDataRef.current = new QueryData<TData, TVariables>({\n      options: updatedOptions as QueryOptions<TData, TVariables>,\n      context,\n      forceUpdate\n    });\n  }\n\n  const queryData = queryDataRef.current;\n  queryData.setOptions(updatedOptions);\n  queryData.context = context;\n\n  // `onError` and `onCompleted` callback functions will not always have a\n  // stable identity, so we'll exclude them from the memoization key to\n  // prevent `afterExecute` from being triggered un-necessarily.\n  const memo = {\n    options: { ...updatedOptions, onError: undefined, onCompleted: undefined },\n    context,\n    tick\n  };\n\n  const result = useDeepMemo(\n    () => (lazy ? queryData.executeLazy() : queryData.execute()),\n    memo\n  );\n\n  const queryResult = lazy\n    ? (result as QueryTuple<TData, TVariables>)[1]\n    : (result as QueryResult<TData, TVariables>);\n\n  useEffect(() => queryData.afterExecute({ lazy }), [\n    queryResult.loading,\n    queryResult.networkStatus,\n    queryResult.error,\n    queryResult.data\n  ]);\n\n  useEffect(() => {\n    return () => queryData.cleanup();\n  }, []);\n\n  return result;\n}\n","import { useRef } from 'react';\nimport { equal as isEqual } from '@wry/equality';\n\n/**\n * Memoize a result using deep equality. This hook has two advantages over\n * React.useMemo: it uses deep equality to compare memo keys, and it guarantees\n * that the memo function will only be called if the keys are unequal.\n * React.useMemo cannot be relied on to do this, since it is only a performance\n * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).\n */\nexport function useDeepMemo<TKey, TValue>(\n  memoFn: () => TValue,\n  key: TKey\n): TValue {\n  const ref = useRef<{ key: TKey; value: TValue }>();\n\n  if (!ref.current || !isEqual(key, ref.current.key)) {\n    ref.current = { key, value: memoFn() };\n  }\n\n  return ref.current.value;\n}\n","import { ApolloError } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  OperationVariables,\n  ExecutionResult,\n  MutationFunctionOptions,\n  MutationResult\n} from '@apollo/react-common';\n\nimport { MutationOptions, MutationTuple } from '../types';\nimport { OperationData } from './OperationData';\n\nexport class MutationData<\n  TData = any,\n  TVariables = OperationVariables\n> extends OperationData {\n  private mostRecentMutationId: number;\n  private result: MutationResult<TData>;\n  private previousResult?: MutationResult<TData>;\n  private setResult: (result: MutationResult<TData>) => any;\n\n  constructor({\n    options,\n    context,\n    result,\n    setResult\n  }: {\n    options: MutationOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    result: MutationResult<TData>;\n    setResult: (result: MutationResult<TData>) => any;\n  }) {\n    super(options, context);\n    this.verifyDocumentType(options.mutation, DocumentType.Mutation);\n    this.result = result;\n    this.setResult = setResult;\n    this.mostRecentMutationId = 0;\n  }\n\n  public execute(result: MutationResult<TData>) {\n    this.isMounted = true;\n    this.verifyDocumentType(this.getOptions().mutation, DocumentType.Mutation);\n    result.client = this.refreshClient().client;\n    return [this.runMutation, result] as MutationTuple<TData, TVariables>;\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    // No cleanup required.\n  }\n\n  private runMutation = (\n    mutationFunctionOptions: MutationFunctionOptions<\n      TData,\n      TVariables\n    > = {} as MutationFunctionOptions<TData, TVariables>\n  ) => {\n    this.onMutationStart();\n    const mutationId = this.generateNewMutationId();\n\n    return this.mutate(mutationFunctionOptions)\n      .then((response: ExecutionResult<TData>) => {\n        this.onMutationCompleted(response, mutationId);\n        return response;\n      })\n      .catch((error: ApolloError) => {\n        this.onMutationError(error, mutationId);\n        if (!this.getOptions().onError) throw error;\n      });\n  };\n\n  private mutate(\n    mutationFunctionOptions: MutationFunctionOptions<TData, TVariables>\n  ) {\n    const {\n      mutation,\n      variables,\n      optimisticResponse,\n      update,\n      context: mutationContext = {},\n      awaitRefetchQueries = false,\n      fetchPolicy\n    } = this.getOptions();\n    const mutateOptions = { ...mutationFunctionOptions };\n\n    const mutateVariables = Object.assign(\n      {},\n      variables,\n      mutateOptions.variables\n    );\n    delete mutateOptions.variables;\n\n    return this.refreshClient().client.mutate({\n      mutation,\n      optimisticResponse,\n      refetchQueries:\n        mutateOptions.refetchQueries || this.getOptions().refetchQueries,\n      awaitRefetchQueries,\n      update,\n      context: mutationContext,\n      fetchPolicy,\n      variables: mutateVariables,\n      ...mutateOptions\n    });\n  }\n\n  private onMutationStart() {\n    if (!this.result.loading && !this.getOptions().ignoreResults) {\n      this.updateResult({\n        loading: true,\n        error: undefined,\n        data: undefined,\n        called: true\n      });\n    }\n  }\n\n  private onMutationCompleted(\n    response: ExecutionResult<TData>,\n    mutationId: number\n  ) {\n    const { onCompleted, ignoreResults } = this.getOptions();\n\n    const { data, errors } = response;\n    const error =\n      errors && errors.length > 0\n        ? new ApolloError({ graphQLErrors: errors })\n        : undefined;\n\n    const callOncomplete = () =>\n      onCompleted ? onCompleted(data as TData) : null;\n\n    if (this.isMostRecentMutation(mutationId) && !ignoreResults) {\n      this.updateResult({\n        called: true,\n        loading: false,\n        data,\n        error\n      });\n    }\n    callOncomplete();\n  }\n\n  private onMutationError(error: ApolloError, mutationId: number) {\n    const { onError } = this.getOptions();\n\n    if (this.isMostRecentMutation(mutationId)) {\n      this.updateResult({\n        loading: false,\n        error,\n        data: undefined,\n        called: true\n      });\n    }\n\n    if (onError) {\n      onError(error);\n    }\n  }\n\n  private generateNewMutationId(): number {\n    return ++this.mostRecentMutationId;\n  }\n\n  private isMostRecentMutation(mutationId: number) {\n    return this.mostRecentMutationId === mutationId;\n  }\n\n  private updateResult(result: MutationResult<TData>) {\n    if (\n      this.isMounted &&\n      (!this.previousResult || !isEqual(this.previousResult, result))\n    ) {\n      this.setResult(result);\n      this.previousResult = result;\n    }\n  }\n}\n","import { equal as isEqual } from '@wry/equality';\nimport { ApolloContextValue, SubscriptionResult } from '@apollo/react-common';\n\nimport { OperationData } from './OperationData';\nimport { SubscriptionCurrentObservable, SubscriptionOptions } from '../types';\n\nexport class SubscriptionData<\n  TData = any,\n  TVariables = any\n> extends OperationData<SubscriptionOptions<TData, TVariables>> {\n  private setResult: any;\n  private currentObservable: SubscriptionCurrentObservable = {};\n\n  constructor({\n    options,\n    context,\n    setResult\n  }: {\n    options: SubscriptionOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    setResult: any;\n  }) {\n    super(options, context);\n    this.setResult = setResult;\n    this.initialize(options);\n  }\n\n  public execute(result: SubscriptionResult<TData>) {\n    if (this.getOptions().skip === true) {\n      this.cleanup();\n      return {\n        loading: false,\n        error: undefined,\n        data: undefined,\n        variables: this.getOptions().variables\n      };\n    }\n\n    let currentResult = result;\n    if (this.refreshClient().isNew) {\n      currentResult = this.getLoadingResult();\n    }\n\n    let { shouldResubscribe } = this.getOptions();\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(this.getOptions());\n    }\n\n    if (\n      shouldResubscribe !== false &&\n      this.previousOptions &&\n      Object.keys(this.previousOptions).length > 0 &&\n      (this.previousOptions.subscription !== this.getOptions().subscription ||\n        !isEqual(this.previousOptions.variables, this.getOptions().variables) ||\n        this.previousOptions.skip !== this.getOptions().skip)\n    ) {\n      this.cleanup();\n      currentResult = this.getLoadingResult();\n    }\n\n    this.initialize(this.getOptions());\n    this.startSubscription();\n\n    this.previousOptions = this.getOptions();\n    return { ...currentResult, variables: this.getOptions().variables };\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n  }\n\n  public cleanup() {\n    this.endSubscription();\n    delete this.currentObservable.query;\n  }\n\n  private initialize(options: SubscriptionOptions<TData, TVariables>) {\n    if (this.currentObservable.query || this.getOptions().skip === true) return;\n    this.currentObservable.query = this.refreshClient().client.subscribe({\n      query: options.subscription,\n      variables: options.variables,\n      fetchPolicy: options.fetchPolicy\n    });\n  }\n\n  private startSubscription() {\n    if (this.currentObservable.subscription) return;\n    this.currentObservable.subscription = this.currentObservable.query!.subscribe(\n      {\n        next: this.updateCurrentData.bind(this),\n        error: this.updateError.bind(this),\n        complete: this.completeSubscription.bind(this)\n      }\n    );\n  }\n\n  private getLoadingResult() {\n    return {\n      loading: true,\n      error: undefined,\n      data: undefined\n    };\n  }\n\n  private updateResult(result: SubscriptionResult) {\n    if (this.isMounted) {\n      this.setResult(result);\n    }\n  }\n\n  private updateCurrentData(result: SubscriptionResult<TData>) {\n    const { onSubscriptionData } = this.getOptions();\n\n    this.updateResult({\n      data: result.data,\n      loading: false,\n      error: undefined\n    });\n\n    if (onSubscriptionData) {\n      onSubscriptionData({\n        client: this.refreshClient().client,\n        subscriptionData: result\n      });\n    }\n  }\n\n  private updateError(error: any) {\n    this.updateResult({\n      error,\n      loading: false\n    });\n  }\n\n  private completeSubscription() {\n    const { onSubscriptionComplete } = this.getOptions();\n    if (onSubscriptionComplete) onSubscriptionComplete();\n    this.endSubscription();\n  }\n\n  private endSubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n}\n","import { ObservableQuery } from 'apollo-client';\nimport { QueryOptions } from '../types';\nimport { DocumentNode } from 'graphql';\nimport { QueryData } from '../data/QueryData';\n\ntype QueryInfo = {\n  seen: boolean;\n  observable: ObservableQuery<any, any> | null;\n};\n\nfunction makeDefaultQueryInfo(): QueryInfo {\n  return {\n    seen: false,\n    observable: null\n  };\n}\n\nexport class RenderPromises {\n  // Map from Query component instances to pending fetchData promises.\n  private queryPromises = new Map<QueryOptions<any, any>, Promise<any>>();\n\n  // Two-layered map from (query document, stringified variables) to QueryInfo\n  // objects. These QueryInfo objects are intended to survive through the whole\n  // getMarkupFromTree process, whereas specific Query instances do not survive\n  // beyond a single call to renderToStaticMarkup.\n  private queryInfoTrie = new Map<DocumentNode, Map<string, QueryInfo>>();\n\n  // Registers the server side rendered observable.\n  public registerSSRObservable<TData, TVariables>(\n    observable: ObservableQuery<any, TVariables>,\n    props: QueryOptions<TData, TVariables>\n  ) {\n    this.lookupQueryInfo(props).observable = observable;\n  }\n\n  // Get's the cached observable that matches the SSR Query instances query and variables.\n  public getSSRObservable<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ) {\n    return this.lookupQueryInfo(props).observable;\n  }\n\n  public addQueryPromise<TData, TVariables>(\n    queryInstance: QueryData<TData, TVariables>,\n    finish: () => React.ReactNode\n  ): React.ReactNode {\n    const info = this.lookupQueryInfo(queryInstance.getOptions());\n    if (!info.seen) {\n      this.queryPromises.set(\n        queryInstance.getOptions(),\n        new Promise(resolve => {\n          resolve(queryInstance.fetchData());\n        })\n      );\n      // Render null to abandon this subtree for this rendering, so that we\n      // can wait for the data to arrive.\n      return null;\n    }\n    return finish();\n  }\n\n  public hasPromises() {\n    return this.queryPromises.size > 0;\n  }\n\n  public consumeAndAwaitPromises() {\n    const promises: Promise<any>[] = [];\n    this.queryPromises.forEach((promise, queryInstance) => {\n      // Make sure we never try to call fetchData for this query document and\n      // these variables again. Since the queryInstance objects change with\n      // every rendering, deduplicating them by query and variables is the\n      // best we can do. If a different Query component happens to have the\n      // same query document and variables, it will be immediately rendered\n      // by calling finish() in addQueryPromise, which could result in the\n      // rendering of an unwanted loading state, but that's not nearly as bad\n      // as getting stuck in an infinite rendering loop because we kept calling\n      // queryInstance.fetchData for the same Query component indefinitely.\n      this.lookupQueryInfo(queryInstance).seen = true;\n      promises.push(promise);\n    });\n    this.queryPromises.clear();\n    return Promise.all(promises);\n  }\n\n  private lookupQueryInfo<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ): QueryInfo {\n    const { queryInfoTrie } = this;\n    const { query, variables } = props;\n    const varMap = queryInfoTrie.get(query) || new Map<string, QueryInfo>();\n    if (!queryInfoTrie.has(query)) queryInfoTrie.set(query, varMap);\n    const variablesString = JSON.stringify(variables);\n    const info = varMap.get(variablesString) || makeDefaultQueryInfo();\n    if (!varMap.has(variablesString)) varMap.set(variablesString, info);\n    return info;\n  }\n}\n","import { OperationVariables } from '@apollo/react-common';\nimport { useQuery } from '@apollo/react-hooks';\nimport PropTypes from 'prop-types';\n\nimport { QueryComponentOptions } from './types';\n\nexport function Query<TData = any, TVariables = OperationVariables>(\n  props: QueryComponentOptions<TData, TVariables>\n) {\n  const { children, query, ...options } = props;\n  const result = useQuery(query, options);\n  return children && result ? children(result) : null;\n}\n\nexport namespace Query {\n  export const propTypes = {\n    client: PropTypes.object,\n    children: PropTypes.func.isRequired,\n    fetchPolicy: PropTypes.string,\n    notifyOnNetworkStatusChange: PropTypes.bool,\n    onCompleted: PropTypes.func,\n    onError: PropTypes.func,\n    pollInterval: PropTypes.number,\n    query: PropTypes.object.isRequired,\n    variables: PropTypes.object,\n    ssr: PropTypes.bool,\n    partialRefetch: PropTypes.bool,\n    returnPartialData: PropTypes.bool\n  };\n}\n","import { OperationVariables, QueryResult } from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { QueryHookOptions } from './types';\nimport { useBaseQuery } from './utils/useBaseQuery';\n\nexport function useQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode,\n  options?: QueryHookOptions<TData, TVariables>\n) {\n  return useBaseQuery<TData, TVariables>(query, options, false) as QueryResult<\n    TData,\n    TVariables\n  >;\n}\n","import { OperationVariables } from '@apollo/react-common';\nimport { useMutation } from '@apollo/react-hooks';\nimport PropTypes from 'prop-types';\n\nimport { MutationComponentOptions } from './types';\n\nexport function Mutation<TData = any, TVariables = OperationVariables>(\n  props: MutationComponentOptions<TData, TVariables>\n) {\n  const [runMutation, result] = useMutation(props.mutation, props);\n  return props.children ? props.children(runMutation, result) : null;\n}\n\nexport namespace Mutation {\n  export const propTypes = {\n    mutation: PropTypes.object.isRequired,\n    variables: PropTypes.object,\n    optimisticResponse: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n    refetchQueries: PropTypes.oneOfType([\n      PropTypes.arrayOf(\n        PropTypes.oneOfType([PropTypes.string, PropTypes.object])\n      ),\n      PropTypes.func\n    ]),\n    awaitRefetchQueries: PropTypes.bool,\n    update: PropTypes.func,\n    children: PropTypes.func.isRequired,\n    onCompleted: PropTypes.func,\n    onError: PropTypes.func,\n    fetchPolicy: PropTypes.string\n  };\n}\n","import { useContext, useState, useRef, useEffect } from 'react';\nimport { getApolloContext, OperationVariables } from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { MutationHookOptions, MutationTuple } from './types';\nimport { MutationData } from './data/MutationData';\n\nexport function useMutation<TData = any, TVariables = OperationVariables>(\n  mutation: DocumentNode,\n  options?: MutationHookOptions<TData, TVariables>\n): MutationTuple<TData, TVariables> {\n  const context = useContext(getApolloContext());\n  const [result, setResult] = useState({ called: false, loading: false });\n  const updatedOptions = options ? { ...options, mutation } : { mutation };\n\n  const mutationDataRef = useRef<MutationData<TData, TVariables>>();\n  function getMutationDataRef() {\n    if (!mutationDataRef.current) {\n      mutationDataRef.current = new MutationData<TData, TVariables>({\n        options: updatedOptions,\n        context,\n        result,\n        setResult\n      });\n    }\n    return mutationDataRef.current;\n  }\n\n  const mutationData = getMutationDataRef();\n  mutationData.setOptions(updatedOptions);\n  mutationData.context = context;\n\n  useEffect(() => mutationData.afterExecute());\n\n  return mutationData.execute(result);\n}\n","import { OperationVariables } from '@apollo/react-common';\nimport { useSubscription } from '@apollo/react-hooks';\nimport PropTypes from 'prop-types';\n\nimport { SubscriptionComponentOptions } from './types';\n\nexport function Subscription<TData = any, TVariables = OperationVariables>(\n  props: SubscriptionComponentOptions<TData, TVariables>\n) {\n  const result = useSubscription(props.subscription, props);\n  return props.children && result ? props.children(result) : null;\n}\n\nexport namespace Subscription {\n  export const propTypes = {\n    subscription: PropTypes.object.isRequired,\n    variables: PropTypes.object,\n    children: PropTypes.func,\n    onSubscriptionData: PropTypes.func,\n    onSubscriptionComplete: PropTypes.func,\n    shouldResubscribe: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  };\n}\n","import { useContext, useState, useRef, useEffect } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { getApolloContext, OperationVariables } from '@apollo/react-common';\n\nimport { SubscriptionHookOptions } from './types';\nimport { SubscriptionData } from './data/SubscriptionData';\n\nexport function useSubscription<TData = any, TVariables = OperationVariables>(\n  subscription: DocumentNode,\n  options?: SubscriptionHookOptions<TData, TVariables>\n) {\n  const context = useContext(getApolloContext());\n  const updatedOptions = options\n    ? { ...options, subscription }\n    : { subscription };\n  const [result, setResult] = useState({\n    loading: !updatedOptions.skip,\n    error: undefined,\n    data: undefined\n  });\n\n  const subscriptionDataRef = useRef<SubscriptionData<TData, TVariables>>();\n  function getSubscriptionDataRef() {\n    if (!subscriptionDataRef.current) {\n      subscriptionDataRef.current = new SubscriptionData<TData, TVariables>({\n        options: updatedOptions,\n        context,\n        setResult\n      });\n    }\n    return subscriptionDataRef.current;\n  }\n\n  const subscriptionData = getSubscriptionDataRef();\n  subscriptionData.setOptions(updatedOptions, true);\n  subscriptionData.context = context;\n\n  useEffect(() => subscriptionData.afterExecute());\n  useEffect(() => subscriptionData.cleanup.bind(subscriptionData), []);\n\n  return subscriptionData.execute(result);\n}\n"],"sourceRoot":""}